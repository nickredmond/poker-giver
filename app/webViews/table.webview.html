<html>
    <head></head>
    <body style="background-color: #dedede">
        <div id="game-area">
            <div style="text-align: center">
                <div id="message-container" onclick="messageBoxDropdownClick()">
                    <div id="message-box" class="message-box-container"></div>
                    <div id="message-box-dropdown-icon" class="arrow-down"></div>
                </div>
                <div id="message-list-box"></div>
                <button id="button-start-game" onclick="startGame()">Start Game</button>
            </div>
            <div style="text-align: center">
                <button id="button-call-check" class="game-button during-hand-button">none</button>
                <button id="button-raise-bet" class="game-button during-hand-button">none</button>
                <button id="button-fold" class="game-button during-hand-button">Fold</button>
                <button id="button-show-cards" class="game-button after-hand-button">Show Cards</button>
                <button id="button-muck" class="game-button after-hand-button">Muck</button>
            </div>
            <div id="flash-message" class="alert alert-info"></div>
            <div id="flash-error" class="alert alert-danger"></div>
            <div id="modal-overlay"></div>
            <div id="bet-amount-dialog">
                <p id="bet-amount-dialog-prompt">Enter amount:</p>
                <input id="bet-amount" type="number" />
                <div id="bet-button-holder">
                    <button id="cancel-button" class="bet-dialog-button" onclick="hideBetAmountDialog()">Cancel</button>
                    <button id="bet-button" class="bet-dialog-button" onclick="onUserPlaceBet()">none</button>
                </div>
            </div>
            <canvas id="tableCanvas" width="100%" height="100%"></canvas>
        </div>
        <div id="game-over-area" style="display: none;">
            <p id="game-over-title">Game Over!</p>
            <div id="game-over-message">Player "yoloswags" wins with 19403 chips.</div>
            <div>Press back button to leave table.</div>
        </div>
        <style>
            #tableCanvas {
                margin-top: 0.5em;
            }

            .game-button {
                position: absolute;
                z-index: 998;
                padding: 0.35em 1em;
                display: none;
                color: white;
                font-weight: bold;
                border: none;
            }
            .during-hand-button {
                width: 7em;
            }
            .after-hand-button {
                width: 7.5em;
                background-color: #0808FF;
            }

            #modal-overlay {
                position: absolute;
                z-index: 999;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: none;
            }

            #bet-amount-dialog {
                position: absolute;
                z-index: 1000;
                padding: 0 1em 1em 1em;
                display: none;
                background-color: #444;
                text-align: center;
            }
            #bet-amount-dialog p {
                color: white;
                font-size: 1.15em;
                margin-bottom: 0.25em;
            }
            #bet-button-holder {
                text-align: center;
            }
            .bet-dialog-button {
                border: none;
                color: white;
                margin-top: 0.5em;
                font-weight: bold;
                font-size: 1.3em;
                padding: 0.25em;
                width: 3.5em;
            }
            #bet-button {
                background-color: #117711;
                margin-left: 0.5em;
            }
            #cancel-button {
                background-color: #991111;
            }

            #button-call-check {
                background-color: #0808FF;
            }
            #button-raise-bet {
                background-color: #117711;
            }
            #button-fold {
                background-color: #991111;
            }

            #bet-amount {
                font-size: 1.2em;
            }

            .message-box-container {
                text-align: center;
                margin-bottom: 0;
                padding: 0.25em 0;
                border: 1px solid #888;
                min-height: 1em;
                font-size: 1.25em;
                background-color: #efefef;
                width: 80%;
            }
            .message-box-item {
                padding: 0.25em 0 0.25em 0.25em;
                border-bottom: 1px solid #888;
            }

            .arrow-down {
                width: 0; 
                height: 0; 
                border-left: 20px solid transparent;
                border-right: 20px solid transparent;
                
                border-top: 20px solid #333;
            }
            .arrow-up {
                width: 0; 
                height: 0; 
                border-left: 20px solid transparent;
                border-right: 20px solid transparent;
                
                border-bottom: 20px solid #333;
            }

            #message-container > div {
                display: inline-block;
            }

            #message-box-dropdown-icon {
                position: relative;
                top: 0.25em;
            }

            #message-list-box {
                position: absolute;
                left: 5%;
                z-index: 999;
                background-color: #eee;
                width: 80%;
            }

            .alert {
                position: absolute;
                top: 2em;
                left: 0.5em;
                right: 0.5em;
                z-index: 1001;
                display: none;
                font-size: 1.1em;

                padding: .75rem 1.25rem;
                margin: 1rem 0.5rem 1rem 0.5rem;
                border: 1px solid transparent;
                border-radius: .25rem;
            }
            .alert-info {
                color: #004085;
                background-color: #cce5ff;
                border-color: #b8daff;
            }
            .alert-danger {
                color: #721c24;
                background-color: #f8d7da;
                border-color: #f5c6cb;
            }

            #game-over-area {
                text-align: center;
                background-color: #222;
                border-radius: 5px;
                padding-bottom: 2em;
                padding-top: 0.75em;
                color: #efefef;
                font-family: Arial, sans-serif;
                font-size: 1.5em;
            }
            #game-over-title {
                font-size: 2em;
                font-weight: bold;
            }
            #game-over-message {
                margin-bottom: 1em;
            }

            #button-start-game {
                width: 50%;
                margin-left: 25%;
                margin-top: 0.5em;
                padding: 0.5em;
                color: white;
                background-color: #117711;
                display: none;
                border: none;
            }
        </style>

        <!-- Utility drawing functions, e.g. rounded rect, circle, etc -->
        <script>
            var maxMessageCount = 20;
            var lastMessages = [];
            var isMessageListDisplayed = false;
            var setMessageText = function(text) {
                lastMessages.push(text);
                if (lastMessages.length > maxMessageCount) {
                    lastMessages = lastMessages.slice(1, maxMessageCount + 1);
                }

                if (isMessageListDisplayed) {
                    var messageListBox = document.getElementById('message-list-box');
                    messageListBox.innerHTML = '';
                    appendMessagesToView(messageListBox);
                }
                else {
                    document.getElementById('message-box').innerHTML = text;
                }
            }

            var messageBoxDropdownClick = function() {
                isMessageListDisplayed = !isMessageListDisplayed;
                var messageListBox = document.getElementById('message-list-box');

                var dropdownIcon = document.getElementById('message-box-dropdown-icon');
                dropdownIcon.classList.remove('arrow-up', 'arrow-down');
                var updatedClass = isMessageListDisplayed ? 'arrow-up' : 'arrow-down';
                dropdownIcon.classList.add(updatedClass);

                if (isMessageListDisplayed) {
                    appendMessagesToView(messageListBox);
                }
                else {
                    messageListBox.innerHTML = '';
                }

                messageListBox.style.display = isMessageListDisplayed ? 'inline-block' : 'none';
            }
            var appendMessagesToView = function(messageListBox) {
                for (var i = lastMessages.length - 1; i >= 0; i--) {
                    if (i === lastMessages.length - 1) {
                        document.getElementById('message-box').innerHTML = lastMessages[i];
                    }
                    else {
                        var messageElement = document.createElement('div');
                        messageElement.innerHTML = lastMessages[i];
                        messageElement.classList.add('message-box-item');
                        messageListBox.appendChild(messageElement);
                    }
                }
            }

            /** https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas */
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke == 'undefined') {
                    stroke = true;
                }
                if (typeof radius === 'undefined') {
                    radius = 5;
                }
                if (typeof radius === 'number') {
                    radius = {tl: radius, tr: radius, br: radius, bl: radius};
                } else {
                    var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
                    for (var side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                    }
                }
                ctx.beginPath();
                ctx.moveTo(x + radius.tl, y);
                ctx.lineTo(x + width - radius.tr, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                ctx.lineTo(x + width, y + height - radius.br);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                ctx.lineTo(x + radius.bl, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                ctx.lineTo(x, y + radius.tl);
                ctx.quadraticCurveTo(x, y, x + radius.tl, y);
                ctx.closePath();
                if (fill) {
                    ctx.fill();
                }
                if (stroke) {
                    ctx.stroke();
                }

            }

            function circle(ctx, centerX, centerY, radius, fillStyle, strokeStyle, lineWidth) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = fillStyle;
                ctx.fill();
                ctx.lineWidth = lineWidth || 3;
                ctx.strokeStyle = strokeStyle;
                ctx.stroke();
            }
        </script>

        <!-- Handle data from React Native -->
        <script>
            var handleMessageFromApp = function(event) {
                // var messageData = JSON.parse(event.data);
                // alert("name: " + messageData.name);
                alert("hmmmm ")
            };
        </script>

        <!-- Get data for game -->
        <script>
            var getAvatarColor = function(playerNumber) {
                var colors = [
                    'purple',
                    'yellow',
                    'blue',
                    'orange',
                    'green',
                    'red',
                    'brown',
                    'pink'
                ];
                return colors[playerNumber - 1];
            }

            var getPlayerDeckLocation = function(playerIndex, tableX, tableY, tableWidth, tableHeight) {
                var deckLocation = {};

                switch (playerIndex) {
                    case 0: 
                        deckLocation = {
                            x: tableX + 20,
                            y: tableY + (tableHeight * 0.5) + 10
                        };
                        break;
                    case 1: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.25),
                            y: tableY + 20
                        };
                        break;
                    case 2: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.5),
                            y: tableY + 20
                        };
                        break;
                    case 3: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.75),
                            y: tableY + 20
                        };
                        break;
                    case 4: 
                        deckLocation = {
                            x: tableX + tableWidth - 20,
                            y: tableY + (tableHeight * 0.5) - 15
                        };
                        break;
                    case 5: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.75),
                            y: tableY + tableHeight - 28
                        };
                        break;
                    case 6: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.5),
                            y: tableY + tableHeight - 28
                        };
                        break;
                    case 7: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.25),
                            y: tableY + tableHeight - 28
                        };
                        break;
                }

                return deckLocation;
            }
        </script>

        <!-- Config data, e.g. sprite image locations -->
        <script>
            var cardsSprite;
            var spritesLocations;
            var spriteWidth;
            var spriteHeight;

            var suitsSprite;

            var loadButtons = function(canvasX, canvasY, canvasWidth, canvasHeight) {
                var buttonsLeft = canvasX + parseInt(canvasWidth * 0.5);

                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.style.top = canvasY + parseInt(canvasHeight * 0.6);
                callCheckButton.style.left = buttonsLeft;

                var raiseBetButton = document.getElementById('button-raise-bet');
                raiseBetButton.style.top = canvasY + parseInt(canvasHeight * 0.7);
                raiseBetButton.style.left = buttonsLeft;

                var foldButton = document.getElementById('button-fold');
                foldButton.style.top = canvasY + parseInt(canvasHeight * 0.8);
                foldButton.style.left = buttonsLeft;

                var showCardsButton = document.getElementById('button-show-cards');
                showCardsButton.style.top = canvasY + parseInt(canvasHeight * 0.6);
                showCardsButton.style.left = buttonsLeft;

                var muckButton = document.getElementById('button-muck');
                muckButton.style.top = canvasY + parseInt(canvasHeight * 0.7);
                muckButton.style.left = buttonsLeft;
            }

            var loadDialogs = function(canvasX, canvasY, canvasWidth, canvasHeight) {
                var betDialogLeft = canvasX + parseInt(canvasWidth * 0.05);
                var betDialogTop = canvasY + parseInt(canvasHeight * 0.25);
                var betDialog = document.getElementById('bet-amount-dialog');
                betDialog.style.left = betDialogLeft;
                betDialog.style.top = betDialogTop;
                betDialog.style.width = parseInt(canvasWidth * 0.75);
            }

            var loadSpritesConfig = function() {
                cardsSprite = new Image();
                cardsSprite.src = 'https://i.ibb.co/ZB85jHT/card-deck-161536-1280.png';

                suitsSprite = new Image();
                suitsSprite.src = 'https://i.ibb.co/R4X28Nd/suits.png';
                
                var numberOfColumns = 13;
                var numberOfRows = 5;
                var widthPerColumn = spriteWidth = cardsSprite.width / numberOfColumns;
                var heightPerColumn = spriteHeight =  cardsSprite.height / numberOfRows;

                spritesLocations = {};
                var ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                var suits = ['Clubs', 'Diamonds', 'Hearts', 'Spades'];
                for (var rank = 0; rank < ranks.length; rank++) {
                    for (var suit = 0; suit < suits.length; suit++) {
                        var x = rank * widthPerColumn;
                        var y = suit * heightPerColumn;
                        var rankName = ranks[rank];
                        var suitName = suits[suit];
                        
                        if (suit === 0) {
                            spritesLocations[rankName] = {};
                        }
                        spritesLocations[rankName][suitName] = { x, y };
                    }
                }
            }

            var userOutlineInterval;
            var animateUserOutline = function() {
                userOutlineInterval = setInterval(() => {
                    userOutlineColor = (userOutlineColor === 'white') ? 'black' : 'white';
                }, 750);
            }
            var stopUserOutlineAnimation = function() {
                if (userOutlineInterval) {
                    clearInterval(userOutlineInterval);
                    userOutlineColor = 'black';
                    userOutlineInterval = null;
                }
            }

            var suitSpriteLocations = {
                'spade': {
                    getX: function() { return 0; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'heart': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'diamond': {
                    getX: function() { return 0; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'club': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                }
            }
        </script>

        <!-- Load data from external source -->
        <script>
            
            
        </script>

        <!-- Draw functions -->
        <script>
            var GOOGLE_PIXEL_WIDTH = 412;
            
            var getNormalizedFontSize = function(defaultFontSize) {
                var fontSize = parseInt(defaultFontSize * getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                return fontSize - (fontSize % 2);
            }

            var drawTable = function(ctx, x, y, width, height) {
                var radius = 50;
                ctx.fillStyle = "#046908";
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 5 * (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                roundRect(ctx, x, y, width, height, radius, true);
            }

            var drawPlayerInfo = function(ctx, text, x, y, yOffset) {
                var xOffset = 5 - parseInt(text.length * 3.5);
                xOffset *= getCanvasWidth() / GOOGLE_PIXEL_WIDTH;
                var finalX = x + xOffset
                var finalY = y + yOffset
                ctx.fillStyle = 'black';
                
                var fontSize = getNormalizedFontSize(12);
                ctx.font = fontSize + 'px Arial';

                ctx.fillText(text, finalX, finalY);
            }

            var userOutlineColor = 'black'; // interval exists to alternate colors
            var drawPlayer = function(ctx, players, playerNumber, x, y, radius) {
                var color = players && players.length >= playerNumber ? getAvatarColor(playerNumber) : 'grey';
                var outlineColor = 'black';
                var playerIndex = playerNumber - 1;
                if (playerIndex === currentPlayerIndex) {
                    outlineColor = userOutlineColor;
                }
                else if (playerIndex === game.currentTurnIndex) {
                    outlineColor = 'white';
                }
                var lineWidth = 3 * (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                circle(ctx, x, y, radius, color, outlineColor);

                var isPlayerInSeat = players && players.length >= playerNumber;
                var playerName = isPlayerInSeat ? players[playerNumber - 1].name || 'N/A' : '[Empty]';
                
                var yOffset = 12 * (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                drawPlayerInfo(ctx, playerName, x, y + radius, yOffset);
                if (isPlayerInSeat) {
                    var playerWorth = players[playerNumber - 1].numberOfChips || 0;
                    yOffset = 25 * (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                    drawPlayerInfo(ctx, playerWorth.toString(), x - 5, y + radius, yOffset);
                }
            }

            var drawPlayers = function(ctx, players, tableX, tableY, tableWidth, tableHeight) {
                var avatarRadius = parseInt(tableWidth / 11);

                var avatarX_left = parseInt(tableX * 0.5);
                var avatarX_center_left = parseInt(tableX + (0.2 * tableWidth));
                var avatarX_center = parseInt(tableX + (0.5 * tableWidth));
                var avatarX_center_right = parseInt(tableX + (0.8 * tableWidth));
                var avatarX_right = parseInt(tableX + (tableWidth * 1.15));

                var avatarY_top = parseInt(tableY * 0.35);
                var avatarY_center = parseInt(tableY + (0.5 * tableHeight));
                var avatarY_bottom = parseInt(tableY + tableHeight + (0.42 * tableY));

                ctx.font = "12px Arial";

                drawPlayer(ctx, players, 1, avatarX_left, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 2, avatarX_center_left, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 3, avatarX_center, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 4, avatarX_center_right, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 5, avatarX_right, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 6, avatarX_center_right, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 7, avatarX_center, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 8, avatarX_center_left, avatarY_bottom, avatarRadius);
            }

            var drawUserCard = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                var fontSize = getNormalizedFontSize(24);
                ctx.font = fontSize + 'px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                var canvasWidthRatio = (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                var xOffset = 8 * canvasWidthRatio;
                var yOffset = 25 * canvasWidthRatio;
                ctx.fillText(rank, x + xOffset, y + yOffset);

                var source = suitSpriteLocations[suit];
                xOffset = 12 * canvasWidthRatio
                yOffset = 28 * canvasWidthRatio;
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + xOffset, y + yOffset, width * 0.7, height * 0.5);
                
                var rightOffsetX = rank.length > 1 ? 27 : 22;
                rightOffsetX *= canvasWidthRatio;
                yOffset = 10 * canvasWidthRatio;
                ctx.fillText(rank, x + width - rightOffsetX, y + height - yOffset);
            }

            var drawUserHand = function(ctx, canvas, rank1, suit1, rank2, suit2) {
                var x = canvas.width * 0.05;
                var y = canvas.height * 0.6;
                var width = canvas.width * 0.2;
                var height = canvas.width * 0.3; 

                var user = game.players[currentPlayerIndex];
                if (user.card1) {
                    drawUserCard(ctx, user.card1.rank, user.card1.suit, x, y, width, height);
                }
                if (user.card2) {
                    drawUserCard(ctx, user.card2.rank, user.card2.suit, x + width - 15, y, width, height);
                }
            };

            var areBlindsSet = function() {
                return (game.bigBlindIndex || game.bigBlindIndex === 0) && (game.littleBlindIndex || game.littleBlindIndex === 0);
            }

            var drawBlinds = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var blindLocations = [
                    { x: tableX + 10, y: tableY + (tableHeight / 2) },
                    { x: tableX + (tableWidth / 3) - (tableWidth / 6), y: tableY + 10 },
                    { x: tableX + (2 * tableWidth / 3) - (tableWidth / 6), y: tableY + 10 },
                    { x: tableX + (5 * tableWidth / 6), y: tableY + 10 },
                    { x: tableX + tableWidth - 15, y: tableY + (tableHeight / 2) + 2 },
                    { x: tableX + (5 * tableWidth / 6), y: tableY + tableHeight - 10 },
                    { x: tableX + (2 * tableWidth / 3) - (tableWidth / 6), y: tableY + tableHeight - 10 },
                    { x: tableX + (tableWidth / 3) - (tableWidth / 6), y: tableY + tableHeight - 10 }
                ];

                var radius = parseInt(5 * (getCanvasWidth() / GOOGLE_PIXEL_WIDTH));
                circle(ctx, blindLocations[game.bigBlindIndex].x, blindLocations[game.bigBlindIndex].y, radius, 'red', 'red', 1);
                circle(ctx, blindLocations[game.bigBlindIndex].x + (2 * radius), blindLocations[game.bigBlindIndex].y, radius, 'red', 'red', 1);
                circle(ctx, blindLocations[game.littleBlindIndex].x, blindLocations[game.littleBlindIndex].y, radius, 'red', 'red', 1);
            }

            var drawPlayerHands = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var index = 0;
                ctx.fillStyle = 'grey';
                var cardWidth = 5 * (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                var cardHeight = 8 * (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);

                game.players.forEach(player => {
                    var playerDeckLocation = getPlayerDeckLocation(index, tableX, tableY, tableWidth, tableHeight);
                    if (player.card1) {
                        ctx.fillRect(playerDeckLocation.x - cardWidth - 1, playerDeckLocation.y, cardWidth, cardHeight);
                    }
                    if (player.card2) {
                        ctx.fillRect(playerDeckLocation.x + 1, playerDeckLocation.y, cardWidth, cardHeight);
                    }

                    index++;
                });

                ctx.fillStyle = 'black';
            }

            var drawCardOnTable = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                var canvasWidthRatio = getCanvasWidth() / GOOGLE_PIXEL_WIDTH;

                ctx.fillStyle = 'black';
                ctx.font = (18 * canvasWidthRatio) + 'px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                var xOffset = 5 * canvasWidthRatio;
                var yOffset = 15 * canvasWidthRatio;
                ctx.fillText(rank, x + xOffset, y + yOffset);

                var source = suitSpriteLocations[suit];
                xOffset = 8 * canvasWidthRatio;
                yOffset = 17 * canvasWidthRatio;
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + xOffset, y + yOffset, width * 0.7, height * 0.5);
            }

            var drawCardsOnTable = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                if (game.cardsOnTable.length > 0) {
                    ctx.lineWidth = 2;
                    var x = parseInt(tableX + (0.16 * tableWidth));
                    var y = parseInt(tableY + (0.28 * tableHeight));
                    var width = parseInt(tableWidth * 0.12);
                    var height = parseInt(width * 1.33);

                    game.cardsOnTable.forEach(card => {
                        drawCardOnTable(ctx, card.rank, card.suit, x, y, width, height);
                        x += tableWidth * 0.14;
                    });
                }
            }

            var drawPot = function(ctx, potAmount, tableX, tableY, tableWidth, tableHeight) {
                var offsetPerDigit = 2;
                var numberOfDigits = potAmount.toString().length;
                var x = tableX + (0.4 * tableWidth) - (offsetPerDigit * numberOfDigits);
                var y = tableY + (0.65 * tableHeight);

                var fontSize = getNormalizedFontSize(16);
                ctx.font = fontSize + 'px Arial';
                ctx.fillStyle = 'white';
                ctx.fillText('pot: ' + potAmount, x, y);
            }

            var drawRevealedHandsOnTable = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var index = 0;

                game.players.forEach(player => {
                    if (player.isShowingHand && player.card1) {
                        var playerDeckLocation = getPlayerDeckLocation(index, tableX, tableY, tableWidth, tableHeight);
                        ctx.lineWidth = 1;
                        var width = parseInt(tableWidth * 0.08);
                        var height = parseInt(width * 1.33);
                        drawRevealedCard(ctx, player.card1.suit, player.card1.rank, playerDeckLocation.x - width - 1, playerDeckLocation.y, width, height);
                        drawRevealedCard(ctx, player.card2.suit, player.card2.rank, playerDeckLocation.x + 1, playerDeckLocation.y, width, height);
                    }

                    index++;
                });
            }
            var drawRevealedCard = function(ctx, suit, rank, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y - 5, width, height, 5, true, false);
                roundRect(ctx, x, y - 5, width, height, 5, false, true);

                var canvasWidthRatio = getCanvasWidth() / GOOGLE_PIXEL_WIDTH;

                ctx.fillStyle = 'black';
                ctx.font = (16 * canvasWidthRatio) + 'px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                var xOffset = 5 * canvasWidthRatio;
                var yOffset = 10 * canvasWidthRatio;
                ctx.fillText(rank, x + xOffset, y + yOffset);
                var source = suitSpriteLocations[suit];

                xOffset = 7 * canvasWidthRatio;
                yOffset = 10 * canvasWidthRatio;
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + xOffset, y + yOffset, width * 0.6, height * 0.4);
            }
        </script>

        

       <script>
           var handleError = function(error) {
               // todo: more gracefully handle this...
               alert("error " + error.name + ": " + error.message + ", " + error.stack);
           }

           var displayMessage = function(message, messageElement) {
                messageElement.innerHTML = message;
                messageElement.style.display = 'block';
                setTimeout(() => {
                    messageElement.style.display = 'none';
                }, 5000);
           }
           var displayFlashMessage = function(message) {
               var flashMessageElement = document.getElementById('flash-message');
               displayMessage(message, flashMessageElement);
           }
           var displayErrorMessage = function(message) {
               var errorMessageElement = document.getElementById('flash-error');
               displayMessage(message, errorMessageElement);
           }

           var hideFlashMessage = function() {
               document.getElementById('flash-message').style.display = 'none';
           }

            var hideButtons = function() {
                document.getElementById('button-call-check').style.display = 'none';
                document.getElementById('button-raise-bet').style.display = 'none';
                document.getElementById('button-fold').style.display = 'none';
            }
            
            var showCallCheckButton = function() {
                var buttonText = isCheck() ? 'Check' : 'Call ' + (game.currentBet - game.players[currentPlayerIndex].currentBet);
                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showRaiseBetButton = function() {
                var buttonText = isBet() ? 'Bet' : 'Raise';
                var callCheckButton = document.getElementById('button-raise-bet');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showFoldButton = function() {
                document.getElementById('button-fold').style.display = 'inherit';
            }

            var showBetAmountDialog = function() {
                document.getElementById('bet-button').innerHTML = isBet() ? 'Bet' : 'Raise';
                document.getElementById('modal-overlay').style.display = 'block';
                document.getElementById('bet-amount-dialog').style.display = 'block';
            }

            var clearBetAmount = function() {
                document.getElementById('bet-amount').value = '';
            }

            var hideBetAmountDialog = function() {
                clearBetAmount();
                document.getElementById('modal-overlay').style.display = 'none';
                document.getElementById('bet-amount-dialog').style.display = 'none';
            }

            var onUserPlaceBet = function() {
                try {
                    var betAmount = parseInt(document.getElementById('bet-amount').value) || 0;
                    if (betAmount) {
                        clearBetAmount();
                        hideBetAmountDialog();
                        var actionType = isBet() ? 'bet' : 'raise';
                        sendUserAction(actionType, betAmount);
                        hideButtons();
                    }
                } catch(error) {
                    handleError(error);
                }
            }

            var sendUserAction = function(actionType, actionAmount, isAutoFold) {
                if (isAutoFold || (!isTimeElapsed && isWaitingForUserAction)) {
                    var actionRequest = {
                        action: 'userAction',
                        actionType: actionType,
                        actionAmount: actionAmount,
                        gameId: game.id
                    };
                    if (actionType === 'showCards') {
                        actionRequest.handId = game.handId;
                        actionRequest.token = currentUserToken;
                    }
                    else {
                        actionRequest.playerName = currentPlayer.name
                    }
                    gameSocket.send(JSON.stringify(actionRequest)); 

                    endTurnTimer();
                }
            }

            // if turn option is betting vs raising
            var isBet = function() {
                return game.currentBet === 0;
            }

            // if turn option is checking vs calling
            var isCheck = function() {
                return game.currentBet === 0 || (game.currentBet === game.bigBlindAmount && game.bigBlindIndex === currentPlayerIndex);
            }

            var setUserActions = function() {
                document.getElementById('button-call-check').onclick = function() {
                    var actionType = isCheck() ? 'check' : 'call';
                    sendUserAction(actionType);
                    hideButtons();
                }

                document.getElementById('button-raise-bet').onclick = function() {
                    showBetAmountDialog();
                }

                document.getElementById('button-fold').onclick = function() {
                    sendUserAction('fold');
                    hideButtons();
                }

                document.getElementById('button-show-cards').onclick = function() {
                    hideLostHandButtons();
                    sendUserAction('showCards');
                }

                document.getElementById('button-muck').onclick = function() {
                    hideLostHandButtons();
                }
            }

            var showLostHandButtons = function() {
                document.getElementById('button-show-cards').style.display = 'block';
                document.getElementById('button-muck').style.display = 'block';
            }

            var hideLostHandButtons = function() {
                document.getElementById('button-show-cards').style.display = 'none';
                document.getElementById('button-muck').style.display = 'none';
            }

         </script>

        <!-- Base logic function (draw, update) -->
        <script>
            var isWaitingForUserAction = false;
            var update = function(millisElapsed) {
                if (isTimeElapsed) {
                    isTimeElapsed = false;
                    currentTurnTimer = 0;

                    if (isWaitingForUserAction) {
                        isWaitingForUserAction = false;
                        hideButtons();
                        displayErrorMessage('Time\'s up! Your hand has been folded.');
                        var isAutoFold = true;
                        sendUserAction('fold', 0, isAutoFold);
                    }
                }
            }
            
            var drawTurnTimer = function(ctx, canvas, millisElapsed) {
                currentTurnTimer -= millisElapsed;

                var x = canvas.width * 0.05;
                var width = canvas.width * 0.2;
                var height = canvas.width * 0.3; 
                var y = canvas.height * 0.6 + height + 10;
                barWidth = x + (2 * width) - 25;

                var turnRatioRemaining = (currentTurnTimer / totalTurnTime);
                var turnRatioPassed = 1 - turnRatioRemaining;
                var currentBarWidth = barWidth * turnRatioRemaining;
                var adjustedX = x + (turnRatioPassed / 2) * barWidth - 10;

                var halfTurnTime = totalTurnTime / 2;
                var timePassed = totalTurnTime - currentTurnTimer;
                var timePastHalf = Math.max(0, timePassed - halfTurnTime);

                var redRatio = Math.min(1, timePassed / halfTurnTime);
                var r = Math.ceil(255 * redRatio);
                
                var greenRatio = timePastHalf > 0 ? 1 - (timePastHalf / halfTurnTime) : 1;
                var g = Math.ceil(255 * greenRatio);

                var barWidthAddition = 20 * turnRatioPassed;
                currentBarWidth += barWidthAddition;

                ctx.fillStyle = 'rgb(' + r + ', ' + g + ', 0)';
                ctx.fillRect(adjustedX, y, currentBarWidth, 5);

                var canvasWidthRatio = (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);
                var fontSize = 28 * canvasWidthRatio;
                ctx.font = fontSize + 'px Arial';
                ctx.fillStyle = 'black';
                var numberOfSecondsRemaining = Math.ceil(currentTurnTimer / totalTurnTime * turnTimerSeconds);
                var yOffset = 30 * canvasWidthRatio;
                var xOffset = 15 * canvasWidthRatio;
                ctx.fillText(numberOfSecondsRemaining, x + (barWidth / 2) - xOffset, y + yOffset);

                if (currentTurnTimer <= 0) {
                    isTimeElapsed = true;
                }
            }

            var isWaitingForTurnTimer = false;
            var draw = function(canvas, millisElapsed) {
                try {
                    var ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    var tableX = parseInt(canvas.width * 0.15);
                    var tableY = parseInt(canvas.width * 0.2);
                    var tableWidth = parseInt(canvas.width * 0.65);
                    var tableHeight = parseInt(canvas.width * 0.35);

                    drawTable(ctx, tableX, tableY, tableWidth, tableHeight);
                    drawPlayers(ctx, game.players, tableX, tableY, tableWidth, tableHeight);

                    if (currentPlayerIndex === 0 || currentPlayerIndex) {
                        drawUserHand(ctx, canvas);
                    }
                    if (currentTurnTimer > 0) {
                        drawTurnTimer(ctx, canvas, millisElapsed);
                    }

                    if (areBlindsSet()) {
                        drawBlinds(ctx, tableX, tableY, tableWidth, tableHeight);
                    }
                    drawPlayerHands(ctx, tableX, tableY, tableWidth, tableHeight);

                    if (isWaitingForTurnTimer) {
                        isWaitingForTurnTimer = false;
                        var turnTimeInSeconds = turnTimerSeconds; // global var
                        startTurnTimer(ctx, millisElapsed, canvas, turnTimeInSeconds);
                    }

                    drawCardsOnTable(ctx, tableX, tableY, tableWidth, tableHeight);
                    var potAmount = game.currentPotAmount || 0;
                    drawPot(ctx, potAmount, tableX, tableY, tableWidth, tableHeight);

                    drawRevealedHandsOnTable(ctx, tableX, tableY, tableWidth, tableHeight);
                } catch(error) {
                    handleError(error);
                }
            }
        </script>

        <!-- turn-taking transition, e.g. deal, flop -->
        <script>
            var handleDealTransition = function(updatedGame, activePlayersCount) {
                try {
                    setMessageText('Dealing...');
                    var gameCopy = JSON.parse(JSON.stringify(updatedGame));
                    game = game || updatedGame;
                    game.cardsOnTable = [];
                    //game.players.forEach(player => {
                    for (var i = 0; i < game.players.length; i++) {
                        var player = game.players[i];
                        player.card1 = null;
                        player.card2 = null;
                        player.isShowingHand = false;
                    }
                    //});

                    var cardTimeout = 0;
                    var cardDealInterval = 200;
                    var roundOfCardsTime = (activePlayersCount - 1) * cardDealInterval;

                    var numberOfCardsDealt = 0;
                    var totalCardsNeeded = activePlayersCount * 2;
                    for (var i = gameCopy.currentTurnIndex; i < gameCopy.currentTurnIndex + gameCopy.players.length; i++) {
                        var currentIndex = i >= gameCopy.players.length ? i - gameCopy.players.length : i;
                        if (!gameCopy.players[currentIndex].isOut) {
                            setTimeout(function(index) {
                                game.players[index].card1 = gameCopy.players[index].card1;
                                numberOfCardsDealt++;
                            }, cardTimeout, currentIndex);
                            setTimeout(function(index) {
                                game.players[index].card2 = gameCopy.players[index].card2;
                                numberOfCardsDealt++;
                                if (numberOfCardsDealt === totalCardsNeeded) {
                                    setMessageText('Player "' + gameCopy.players[gameCopy.currentTurnIndex].name + '"\'s turn.');
                                    game = gameCopy;
                                    handleUserButtons();
                                }
                            }, cardTimeout + roundOfCardsTime, currentIndex);
                            cardTimeout += cardDealInterval;
                        }
                    }
                } catch (error) {
                    handleError(error);
                }
            }

            var handleFlopTransition = function(updatedGame) {
                try {
                    var timeout = 0;
                    for (var i = 0; i < 3; i++) {
                        setTimeout((index) => {
                            try{
                                if (index === 2) {
                                    game = updatedGame;
                                }
                                else {
                                    game.cardsOnTable.push(updatedGame.cardsOnTable[index]);
                                }
                            } catch (error) {
                                handleError(error);
                            }
                        }, timeout, i);
                        timeout += 300;
                    }
                } catch (error) {
                    handleError(error);
                }
            }
        </script>

        <!-- communication w/ server -->
        <script>
            var beginPing = function() {
                setInterval(() => {
                    gameSocket.send(JSON.stringify({ action: 'ping' }));
                }, 25000);
            }

            var handleMessageFromServer = function(message) {
                var isGameSetInstantly = true;

                if (message.action) {
                    switch (message.action) {
                        case 'deal':
                            hideFlashMessage();
                            isGameSetInstantly = false;
                            handleDealTransition(message.game, message.activePlayersCount);
                            break;
                        case 'flop': 
                            isGameSetInstantly = false;
                            handleFlopTransition(message.game);
                            break;
                        case 'playerAdded':
                            if (message.playerName !== currentPlayer.name) {
                                var matchingPlayers = game.players.filter(player => {
                                    return player.name === message.playerName;
                                });
                                if (matchingPlayers.length > 0) {
                                    matchingPlayers[0].numberOfChips += message.numberOfChips;
                                }
                                displayFlashMessage('Player "' + message.playerName + '" has joined the game.');
                            }
                            break;
                        case 'playerLeft':
                            displayFlashMessage('Player "' + message.playerName + '" has left the game.');
                            break;
                        case 'gameOver':
                            var message = message.winningPlayerName === currentPlayer.name ?
                                'You win with ' + message.numberOfChipsWon + ' chips.' : 
                                'Player "' + message.winningPlayerName + '" wins with ' + message.numberOfChipsWon + ' chips.'; 
                            document.getElementById('game-over-message').innerHTML = message;
                            document.getElementById('game-area').style.display = 'none';
                            document.getElementById('game-over-area').style.display = 'block';
                            break;
                        case 'joinGame': 
                           if (message.playerName !== currentPlayer.name) {
                                var message = 'Player "' + message.playerName + '" has joined the game.';
                                displayFlashMessage(message);
                           }
                            break;
                    }
                }

                if (message.game) {
                    isShowingLostHandButtons = false;

                    if (currentPlayerIndex === null) {
                        for (var i = 0; i < message.game.players.length && currentPlayerIndex === null; i++) {
                            if (message.game.players[i].name === currentPlayer.name) {
                                currentPlayerIndex = i;
                            }
                        }
                    }

                    if (isGameSetInstantly) {
                        game = message.game;
                        handleShowCardsOrMuck();
                        handleUserButtons();
                    }
                    if (!isShowingLostHandButtons) { // gets set to true sometimes in handleshowcardsormuck
                        hideLostHandButtons();
                    }
                }

                if (message.message) {
                    setMessageText(message.message);
                }
            }

            var beginListenForMessages = function() {
                gameSocket.onmessage = function(event) {
                    try {
                        var message = JSON.parse(event.data);
                        if (message.isTableFull) {
                            displayErrorMessage('Table is full! Please try another table.');
                        }
                        else if (message.errorMessage) {
                            displayErrorMessage('There was a problem joining the table.');
                        }
                        else {
                            handleMessageFromServer(message);
                        }
                    } catch (error) {
                        handleError(error);
                    }
                };
            }

            var handleUserButtons = function() {
                try {
                    var isHandOver = game.players.filter(player => {
                        return player.isShowingHand;
                    }).length > 0;

                    var nextPlayer = game.players[game.currentTurnIndex];
                    if (nextPlayer && !isHandOver && !nextPlayer.isOut && nextPlayer.name === currentPlayer.name) {
                        showCallCheckButton();
                        showRaiseBetButton();
                        showFoldButton();
                        isWaitingForUserAction = true;
                        isWaitingForTurnTimer = true;
                            
                        if (!userOutlineInterval) {
                            animateUserOutline();
                        }
                    } else {
                        hideButtons();
                        stopUserOutlineAnimation();
                    }
                } catch (error) {
                    handleError(error);
                }
            }

            var currentTurnTimer = 0; // in millis
            var totalTurnTime = 0;
            var isTimeElapsed = false;
            var barWidth = 0;
            var startTurnTimer = function(ctx, millisElapsed, canvas, turnTimeInSeconds) {
                // x + 2w - 15
                isTimeElapsed = false;
                currentTurnTimer = totalTurnTime = turnTimeInSeconds * 1000;
            }
            var endTurnTimer = function() {
                currentTurnTimer = 0;
                totalTurnTime = 0;
            }

            var isShowingLostHandButtons = false;
            var handleShowCardsOrMuck = function() {
                try {
                    var winningPlayers = game.players.filter(player => {
                        return player.isShowingHand;
                    });

                    var isCurrentPlayerWinner = false;
                    winningPlayers.forEach(player => {
                        if (game.players[currentPlayerIndex].name === player.name) {
                            isCurrentPlayerWinner = true;
                        }
                        player.isShowingHand = true;
                    });
                    if (winningPlayers.length && !isCurrentPlayerWinner && game.players[currentPlayerIndex].card1) {
                        showLostHandButtons();
                        isShowingLostHandButtons = true;
                    }
                } catch (error) {
                    handleError(error);
                }
            }

            var sendAddChipsRequest = function(numberOfChips) {
                var addChipsRequest = {
                    action: 'addChips',
                    gameId: game.id,
                    playerName: currentPlayer.name,
                    numberOfChips: numberOfChips
                };
                gameSocket.send(JSON.stringify(addChipsRequest));
            }

            var startGame = function() {
                var startGameRquest = {
                    action: 'startGame',
                    gameId: game.id,
                    token: currentUserToken
                };
                gameSocket.send(JSON.stringify(startGameRquest));
                document.getElementById('button-start-game').style.display = 'none';
            }

            var getCanvasWidth = function() {
                return document.getElementById('tableCanvas').width;
            }

            var setButtonsSize = function() {
                var canvasWidthRatio = (getCanvasWidth() / GOOGLE_PIXEL_WIDTH);

                var gameButtons = document.getElementsByClassName('game-button');
                var gameButtonsFontSize = 1.25 * canvasWidthRatio;
                [].forEach.call(gameButtons, function(button) {
                    button.style.fontSize = gameButtonsFontSize + 'em';
                })
                
                var dialogText = document.getElementById('bet-amount-dialog-prompt');
                dialogText.style.fontSize = (1.25 * canvasWidthRatio) + 'em';

                var betDialogButtons = document.getElementsByClassName('bet-dialog-button');
                var buttonsFontSize = canvasWidthRatio;
                [].forEach.call(betDialogButtons, function(button) {
                    button.style.fontSize = buttonsFontSize + 'em';
                });

                var buttonStartSame = document.getElementById('button-start-game');
                buttonStartSame.style.fontSize = (1.25 * canvasWidthRatio) + 'em';

                var messageBox = document.getElementById('message-box');
                var messageListBox = document.getElementById('message-list-box');
                var messageFontSize = 1.15 * canvasWidthRatio;
                messageBox.style.fontSize = messageFontSize + 'em';
                messageListBox.style.fontSize = messageFontSize + 'em';

                var flashMessage = document.getElementById('flash-message');
                var flashError = document.getElementById('flash-error');
                flashMessage.style.fontSize = messageFontSize + 'em';
                flashError.style.fontSize = messageFontSize + 'em';
            }
        </script>

        <script>
            var game = null;
            var currentPlayer = null;
            var currentPlayerIndex = null;
            var gameSocket = null;
            var isBoughtIn = false;
            var currentUserToken = null; // todo: move to local storage or something?
            var turnTimerSeconds = 0;

            window.onload = function() {
                try {
                    gameSocket = new WebSocket('wss://www.poker-giver.com/');
                    beginPing();
                } catch (err) {
                    alert('Error connecting to game. ' + err.name + ': ' + err.message + ', ' + err.stack);
                }

                // /// GAME READY/INIT
               document.addEventListener("message", function(event) {
                   try {
                        var messageData =  JSON.parse(event.data);

                        if (isBoughtIn) {
                            sendAddChipsRequest(messageData.numberOfChips);
                            displayFlashMessage(messageData.numberOfChips + ' chips will be added at the end of the round.');
                        }
                        else {
                            currentPlayerIndex = null;
                            game = null;
                            isBoughtIn = true;
                            currentPlayer = messageData.player;
                            turnTimerSeconds = messageData.turnTimerSeconds;

                        // gameSocket.onopen = function() {
                                var gameJoinRequest = {
                                    action: 'joinGame',
                                    gameId: messageData.gameId,
                                    playerName: currentPlayer.name,
                                    buyInAmount: messageData.numberOfChips,
                                    token: messageData.token
                                    // todo: send token on all requests
                                };
                                currentUserToken = messageData.token;
                                gameSocket.send(JSON.stringify(gameJoinRequest));
                        // }

                            if (messageData.isAuthor) {
                                var startGameButton = document.getElementById('button-start-game');
                                startGameButton.style.display = 'block';
                            }

                            beginListenForMessages();
                        }
                   } catch (err) {
                       setMessageText('Error joining game.');
                       alert('Error joining table ' + err.name + ', ' + err.message)
                   }
               });

                try {
                    setUserActions();

                    var canvas = document.getElementById('tableCanvas');
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight - 20;
                    var canvasRect = canvas.getBoundingClientRect();

                    loadSpritesConfig();
                    loadButtons(canvasRect.left, canvasRect.top, canvas.width, canvas.height);
                    loadDialogs(canvasRect.left, canvasRect.top, canvas.width, canvas.height);

                    setButtonsSize();

                    var millisElapsed = 1000 / 24;
                    setInterval(function() {
                        if (game && currentPlayer) {
                            update(millisElapsed);
                            draw(canvas, millisElapsed);
                        }
                    }, millisElapsed);

                    setMessageText("Joining table...");
                } catch (err) {
                    alert('Its an err ' + err.name + ', ' + err.message + ', ' + err.stack)
                    setMessageText('Error joining game.');
                }
            }
        </script>

        
    </body>
</html>