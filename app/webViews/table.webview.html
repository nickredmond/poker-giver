<html>
    <head></head>
    <body style="background-color: #dedede">
        <div id="testdiv">testtesttest</div>
        <button id="button-call-check" class="game-button">none</button>
        <button id="button-raise-bet" class="game-button">none</button>
        <button id="button-fold" class="game-button">Fold</button>
        <div id="bet-amount-dialog">
            <span>Enter amount:&nbsp;</span>
            <input id="bet-amount" type="number" />
            <button onclick="onUserPlaceBet()">Place</button>
        </div>
        <canvas id="tableCanvas" width="100%" height="100%"></canvas>
        <style>
            .game-button {
                position: absolute;
                z-index: 1000;
                padding: 0.25em 1em;
                font-size: 1.25em;
                display: none;
            }

            #betting-dialog {
                position: absolute;
                z-index: 1000;
                padding: 1em;
                display: none;
            }
        </style>

        <!-- Utility drawing functions, e.g. rounded rect, circle, etc -->
        <script>
            var setTestText = function(text) {
                document.getElementById('testdiv').innerHTML = text;
            }

            /** https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas */
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke == 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            if (typeof radius === 'number') {
                radius = {tl: radius, tr: radius, br: radius, bl: radius};
            } else {
                var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
                for (var side in defaultRadius) {
                radius[side] = radius[side] || defaultRadius[side];
                }
            }
            ctx.beginPath();
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + width - radius.tr, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
            ctx.lineTo(x + width, y + height - radius.br);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
            ctx.lineTo(x + radius.bl, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }

            }

            function circle(ctx, centerX, centerY, radius, fillStyle, strokeStyle, lineWidth) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = fillStyle;
                ctx.fill();
                ctx.lineWidth = lineWidth || 3;
                ctx.strokeStyle = strokeStyle;
                ctx.stroke();
            }
        </script>

        <!-- Handle data from React Native -->
        <script>
            var handleMessageFromApp = function(event) {
                // var messageData = JSON.parse(event.data);
                // alert("name: " + messageData.name);
                alert("hmmmm ")
            };
        </script>

        <!-- Constants -->
        <script>
            var DECK_OF_CARDS = [
                { rank: 'A', suit: 'spade' }, { rank: 'A', suit: 'diamond' }, { rank: 'A', suit: 'club' }, { rank: 'A', suit: 'heart' },
                { rank: '2', suit: 'spade' }, { rank: '2', suit: 'diamond' }, { rank: '2', suit: 'club' }, { rank: '2', suit: 'heart' },
                { rank: '3', suit: 'spade' }, { rank: '3', suit: 'diamond' }, { rank: '3', suit: 'club' }, { rank: '3', suit: 'heart' },
                { rank: '4', suit: 'spade' }, { rank: '4', suit: 'diamond' }, { rank: '4', suit: 'club' }, { rank: '4', suit: 'heart' },
                { rank: '5', suit: 'spade' }, { rank: '5', suit: 'diamond' }, { rank: '5', suit: 'club' }, { rank: '5', suit: 'heart' },
                { rank: '6', suit: 'spade' }, { rank: '6', suit: 'diamond' }, { rank: '6', suit: 'club' }, { rank: '6', suit: 'heart' },
                { rank: '7', suit: 'spade' }, { rank: '7', suit: 'diamond' }, { rank: '7', suit: 'club' }, { rank: '7', suit: 'heart' },
                { rank: '8', suit: 'spade' }, { rank: '8', suit: 'diamond' }, { rank: '8', suit: 'club' }, { rank: '8', suit: 'heart' },
                { rank: '9', suit: 'spade' }, { rank: '9', suit: 'diamond' }, { rank: '9', suit: 'club' }, { rank: '9', suit: 'heart' },
                { rank: '10', suit: 'spade' }, { rank: '10', suit: 'diamond' }, { rank: '10', suit: 'club' }, { rank: '10', suit: 'heart' },
                { rank: 'J', suit: 'spade' }, { rank: 'J', suit: 'diamond' }, { rank: 'J', suit: 'club' }, { rank: 'J', suit: 'heart' },
                { rank: 'Q', suit: 'spade' }, { rank: 'Q', suit: 'diamond' }, { rank: 'Q', suit: 'club' }, { rank: 'Q', suit: 'heart' },
                { rank: 'K', suit: 'spade' }, { rank: 'K', suit: 'diamond' }, { rank: 'K', suit: 'club' }, { rank: 'K', suit: 'heart' },
            ];
        </script>

        <!-- Get data for game -->
        <script>
            var getPlayers = function() {
                // sent from react native
                return players || [];
            };

            var getAvatarColor = function(playerNumber) {
                var colors = [
                    'purple',
                    'yellow',
                    'blue',
                    'orange',
                    'green',
                    'red',
                    'brown',
                    'pink'
                ];
                return colors[playerNumber - 1];
            }

            var getPlayerDeckLocation = function(playerIndex, tableStart, tableWidth, tableHeight) {
                var deckLocation = {};

                switch (playerIndex) {
                    case 0: 
                        deckLocation = {
                            x: tableStart + 20,
                            y: tableStart + (tableHeight * 0.5) + 10
                        };
                        break;
                    case 1: 
                        deckLocation = {
                            x: tableStart + (tableWidth * 0.25),
                            y: tableStart + 20
                        };
                        break;
                    case 2: 
                        deckLocation = {
                            x: tableStart + (tableWidth * 0.5),
                            y: tableStart + 20
                        };
                        break;
                    case 3: 
                        deckLocation = {
                            x: tableStart + (tableWidth * 0.75),
                            y: tableStart + 20
                        };
                        break;
                    case 4: 
                        deckLocation = {
                            x: tableStart + tableWidth - 20,
                            y: tableStart + (tableHeight * 0.5) - 15
                        };
                        break;
                    case 5: 
                        deckLocation = {
                            x: tableStart + (tableWidth * 0.75),
                            y: tableStart + tableHeight - 28
                        };
                        break;
                    case 6: 
                        deckLocation = {
                            x: tableStart + (tableWidth * 0.5),
                            y: tableStart + tableHeight - 28
                        };
                        break;
                    case 7: 
                        deckLocation = {
                            x: tableStart + (tableWidth * 0.25),
                            y: tableStart + tableHeight - 28
                        };
                        break;
                }

                return deckLocation;
            }
        </script>

        <!-- Config data, e.g. sprite image locations -->
        <script>
            var cardsSprite;
            var spritesLocations;
            var spriteWidth;
            var spriteHeight;

            var suitsSprite;

            var loadButtons = function(canvasX, canvasY, canvasWidth, canvasHeight) {
                var buttonsLeft = canvasX + parseInt(canvasWidth * 0.5);

                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.style.top = canvasY + parseInt(canvasHeight * 0.6);
                callCheckButton.style.left = buttonsLeft;

                var raiseBetButton = document.getElementById('button-raise-bet');
                raiseBetButton.style.top = canvasY + parseInt(canvasHeight * 0.7);
                raiseBetButton.style.left = buttonsLeft;

                var foldButton = document.getElementById('button-fold');
                foldButton.style.top = canvasY + parseInt(canvasHeight * 0.8);
                foldButton.style.left = buttonsLeft;
            }

            var loadSpritesConfig = function() {
                cardsSprite = new Image();
                cardsSprite.src = 'https://i.ibb.co/ZB85jHT/card-deck-161536-1280.png';

                suitsSprite = new Image();
                suitsSprite.src = 'https://i.ibb.co/R4X28Nd/suits.png';
                
                var numberOfColumns = 13;
                var numberOfRows = 5;
                var widthPerColumn = spriteWidth = cardsSprite.width / numberOfColumns;
                var heightPerColumn = spriteHeight =  cardsSprite.height / numberOfRows;

                spritesLocations = {};
                var ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                var suits = ['Clubs', 'Diamonds', 'Hearts', 'Spades'];
                for (var rank = 0; rank < ranks.length; rank++) {
                    for (var suit = 0; suit < suits.length; suit++) {
                        var x = rank * widthPerColumn;
                        var y = suit * heightPerColumn;
                        var rankName = ranks[rank];
                        var suitName = suits[suit];
                        
                        if (suit === 0) {
                            spritesLocations[rankName] = {};
                        }
                        spritesLocations[rankName][suitName] = { x, y };
                    }
                }
            }

            var suitSpriteLocations = {
                'spade': {
                    getX: function() { return 0; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'heart': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'diamond': {
                    getX: function() { return 0; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'club': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                }
            }
        </script>

        <!-- Load data from external source -->
        <script>
            
            
        </script>

        <!-- Draw functions -->
        <script>
            var drawTable = function(ctx, x, y, width, height) {
                var radius = 50;
                ctx.fillStyle = "#046908";
                ctx.strokeStyle = 'black';
                roundRect(ctx, x, y, width, height, radius, true);
            }

            var drawPlayerInfo = function(ctx, text, x, y, yOffset) {
                var xOffset = 5 - parseInt(text.length * 3.5);
                var finalX = x + xOffset
                var finalY = y + yOffset
                ctx.fillStyle = 'black';
                ctx.fillText(text, finalX, finalY);
            }

            var userOutlineColor = 'black'; // interval exists to alternate colors
            var drawPlayer = function(ctx, players, playerNumber, x, y, radius) {
                var color = players && players.length >= playerNumber ? getAvatarColor(playerNumber) : 'grey';
                var outlineColor = 'black';
                var playerIndex = playerNumber - 1;
                if (playerIndex === currentPlayerIndex) {
                    outlineColor = userOutlineColor;
                }
                else if (playerIndex === currentTurnIndex) {
                    outlineColor = 'white';
                }
                circle(ctx, x, y, radius, color, outlineColor);

                var isPlayerInSeat = players && players.length >= playerNumber;
                var playerName = isPlayerInSeat ? players[playerNumber - 1].name : '[Empty]';
                drawPlayerInfo(ctx, playerName, x, y + radius, 12);
                if (isPlayerInSeat) {
                    var playerWorth = players[playerNumber - 1].numberOfChips || 0;
                    drawPlayerInfo(ctx, playerWorth.toString(), x - 5, y + radius, 25);
                }
            }

            var drawPlayers = function(ctx, players, tableStart, tableWidth, tableHeight) {
                var avatarRadius = parseInt(tableWidth / 11);

                var avatarX_left = parseInt(tableStart * 0.5);
                var avatarX_center_left = parseInt(tableStart + (0.2 * tableWidth));
                var avatarX_center = parseInt(tableStart + (0.5 * tableWidth));
                var avatarX_center_right = parseInt(tableStart + (0.8 * tableWidth));
                var avatarX_right = parseInt(tableStart + tableWidth + (0.5 * tableStart));

                var avatarY_top = parseInt(tableStart * 0.33);
                var avatarY_center = parseInt(tableStart + (0.5 * tableHeight));
                var avatarY_bottom = parseInt(tableStart + tableHeight + (0.4 * tableStart));

                

                ctx.font = "12px Arial";

                drawPlayer(ctx, players, 1, avatarX_left, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 2, avatarX_center_left, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 3, avatarX_center, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 4, avatarX_center_right, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 5, avatarX_right, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 6, avatarX_center_right, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 7, avatarX_center, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 8, avatarX_center_left, avatarY_bottom, avatarRadius);

                playerName = players && players.length >= 2
            }

            var drawUserCard = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                ctx.fillText(rank, x + 8, y + 25);
                var source = suitSpriteLocations[suit];
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + 12, y + 28, width * 0.7, height * 0.5);
                var rightOffsetX = rank.length > 1 ? 27 : 22;
                ctx.fillText(rank, x + width - rightOffsetX, y + height - 10);
            }

            var drawUserHand = function(ctx, canvas, rank1, suit1, rank2, suit2) {
                var x = canvas.width * 0.05;
                var y = canvas.height * 0.6;
                var width = canvas.width * 0.2;
                var height = canvas.width * 0.3; 

                var user = players[currentPlayerIndex];
                if (user.card1) {
                    drawUserCard(ctx, user.card1.rank, user.card1.suit, x, y, width, height);
                }
                if (user.card2) {
                    drawUserCard(ctx, user.card2.rank, user.card2.suit, x + width - 15, y, width, height);
                }
            };

            var drawBlinds = function(ctx, tableStart, tableWidth, tableHeight) {
                var blindLocations = [
                    { x: tableStart + 10, y: tableStart + (tableHeight / 2) },
                    { x: tableStart + (tableWidth / 3) - (tableWidth / 6), y: tableStart + 10 },
                    { x: tableStart + (2 * tableWidth / 3) - (tableWidth / 6), y: tableStart + 10 },
                    { x: tableStart + (5 * tableWidth / 6), y: tableStart + 10 },
                    { x: tableStart + tableWidth - 10, y: tableStart + (tableHeight / 2) },
                    { x: tableStart + (5 * tableWidth / 6), y: tableStart + tableHeight - 10 },
                    { x: tableStart + (2 * tableWidth / 3) - (tableWidth / 6), y: tableStart + tableHeight - 10 },
                    { x: tableStart + (tableWidth / 3) - (tableWidth / 6), y: tableStart + tableHeight - 10 }
                ];

                circle(ctx, blindLocations[bigBlindIndex].x, blindLocations[bigBlindIndex].y, 5, 'red', 'red', 1);
                circle(ctx, blindLocations[bigBlindIndex].x + 10, blindLocations[bigBlindIndex].y, 5, 'red', 'red', 1);
                circle(ctx, blindLocations[littleBlindIndex].x, blindLocations[littleBlindIndex].y, 5, 'red', 'red', 1);
            }

            var drawPlayerHands = function(ctx, tableStart, tableWidth, tableHeight) {
                var index = 0;
                ctx.fillStyle = 'grey';

                players.forEach(player => {
                    var playerDeckLocation = getPlayerDeckLocation(index, tableStart, tableWidth, tableHeight);
                    if (player.card1) {
                        ctx.fillRect(playerDeckLocation.x - 6, playerDeckLocation.y, 5, 8);
                    }
                    if (player.card2) {
                        ctx.fillRect(playerDeckLocation.x + 1, playerDeckLocation.y, 5, 8);
                    }

                    index++;
                });

                ctx.fillStyle = 'black';
            }

            var drawCardOnTable = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                ctx.fillText(rank, x + 8, y + 25);
                var source = suitSpriteLocations[suit];
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + 12, y + 28, width * 0.7, height * 0.5);
                var rightOffsetX = rank.length > 1 ? 27 : 22;
                ctx.fillText(rank, x + width - rightOffsetX, y + height - 10);
            }

            var drawCardsOnTable = function(ctx, tableStart, tableWidth, tableHeight) {
                if (cardsOnTable.length > 0) {
                    var x = parseInt(tableStart + (0.15 * tableWidth));
                    var y = parseInt(tableStart + (0.3 * tableHeight));
                    var width = parseInt(tableWidth * 0.1);
                    var height = parseInt(width * 1.33);

                    cardsOnTable.forEach(card => {
                        drawCardOnTable(ctx, card.rank, card.suit, x, y, width, height);
                        x += tableWidth * 0.12;
                    });
                }
            }
        </script>

        <!-- AI logic functions -->
        <script>
            var beginAiTurn = function(onTurnComplete) {

            }
        </script>

        <!-- Logic functions -->
        <script>
            var currentDeck;
            var shuffleCards = function() {
                var unshuffledCards = JSON.parse(JSON.stringify(DECK_OF_CARDS));
                var shuffledCards = [];

                for (var i = 0; i < DECK_OF_CARDS.length; i++) {
                    var nextCardIndex = Math.floor(Math.random() * unshuffledCards.length);
                    shuffledCards.push(unshuffledCards[nextCardIndex]);
                    unshuffledCards.splice(nextCardIndex, 1);
                }

                return shuffledCards;
            }

            var bigBlindIndex;
            var littleBlindIndex;
            var bigBlindAmount;
            var littleBlindAmount;

            var incrementBlinds = function() {
                if (!bigBlindIndex && bigBlindIndex !== 0) {
                    bigBlindIndex = Math.floor(Math.random() * players.length);
                    littleBlindIndex = bigBlindIndex === 0 ? players.length - 1 : bigBlindIndex - 1;
                }
                else {
                    bigBlindIndex++;
                    littleBlindIndex++;
                    if (bigBlindIndex >= players.length) {
                        bigBlindIndex = 0;
                    }
                    if (littleBlindIndex >= players.length) {
                        littleBlindIndex = 0;
                    }
                }
            }

            var deductBlindsFromPlayers = function() {
                players[bigBlindIndex].numberOfChips -= bigBlindAmount;
                players[bigBlindIndex].currentBet = bigBlindAmount;
                if (players[bigBlindIndex].numberOfChips < 0) {
                    players[bigBlindIndex].numberOfChips = 0;
                }

                players[littleBlindIndex].numberOfChips -= littleBlindAmount;
                players[littleBlindIndex].currentBet = littleBlindAmount;
                if (players[littleBlindIndex].numberOfChips < 0) {
                    players[littleBlindIndex].numberOfChips = 0;
                }
            }

            var areBlindsSet = function() {
                return (bigBlindIndex || bigBlindIndex === 0) && (littleBlindIndex || littleBlindIndex === 0);
            }

            var drawCardFromDeck = function() {
                var nextCard = currentDeck[0];
                currentDeck = currentDeck.slice(0, 1);
                return nextCard;
            }

            var currentTurnIndex;
            var numberOfTurnsPlayed = 0;
            var currentBet = 0;
            var currentPotAmount = 0;
            var isBigBlindRaised = false;
            var beginDeal = function(onDealComplete) {
                isBigBlindRaised = false;
                numberOfTurnsPlayed = 0;

                incrementBlinds();
                currentBet = bigBlindAmount;
                currentPotAmount = bigBlindAmount + littleBlindAmount;
                players.forEach(player => {
                    player.currentBet = 0;
                });
                deductBlindsFromPlayers();

                currentDeck = shuffleCards();
                var cardTimeout = 0;
                var cardDealInterval = 200;
                var roundOfCardsTime = (players.length - 1) * cardDealInterval;

                currentTurnIndex = bigBlindIndex + 1;
                if (currentTurnIndex >= players.length) {
                    currentTurnIndex = 0;
                }

                var numberOfCardsDealt = 0;
                var totalCardsNeeded = players.length * 2;
                for (var i = currentTurnIndex; i < currentTurnIndex + players.length; i++) {
                    var currentIndex = i >= players.length ? i - players.length : i;
                    var player = players[currentIndex];
                    player.card1 = null;
                    player.card2 = null;

                    setTimeout(function(nextPlayer) {
                        var nextCard = drawCardFromDeck();
                        nextPlayer.card1 = nextCard;
                        numberOfCardsDealt++;
                    }, cardTimeout, player);

                    setTimeout(function(nextPlayer) {
                        var nextCard = drawCardFromDeck();
                        nextPlayer.card2 = nextCard;
                        numberOfCardsDealt++;

                        if (numberOfCardsDealt === totalCardsNeeded) {
                            onDealComplete();
                        }
                    }, cardTimeout + roundOfCardsTime, player);

                    cardTimeout += cardDealInterval;
                }
            }

            var hideButtons = function() {
                document.getElementById('button-call-check').style.display = 'none';
                document.getElementById('button-raise-bet').style.display = 'none';
                document.getElementById('button-fold').style.display = 'none';
            }
            
            var showCallCheckButton = function() {
                var buttonText = isCheck() ? 'Check' : 'Call ' + (currentBet - players[currentPlayerIndex].currentBet);
                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showRaiseBetButton = function() {
                var buttonText = isBet() ? 'Bet' : 'Raise ' + currentBet;
                var callCheckButton = document.getElementById('button-raise-bet');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showFoldButton = function() {
                document.getElementById('button-fold').display = 'inherit';
            }

            var showBetAmountDialog = function() {
                document.getElementById('bet-amount-dialog').style.display = 'block';
            }

            var onUserPlaceBet = function() {
                var betAmount = document.getElementById('bet-amount').value;
                onNextUserAction('bet', betAmount);
            }

            // if turn option is betting vs raising
            var isBet = function() {
                return currentBet === 0;
            }

            // if turn option is checking vs calling
            var isCheck = function() {
                return currentBet === 0 || (currentBet === bigBlindAmount && bigBlindIndex === currentPlayerIndex);
            }

            // returns hand containing rank (royal flush for this method) or null if no hand
            var getRoyalFlush = function(cards) {
                var straightFlush;
                var royalFlush = null;

                if (cards.length >= 5) {
                    straightFlush = getStraightFlush(cards);
                }
                if (straightFlush && straightFlush[0].rank === 'A') {
                    royalFlush = straightFlush;
                }

                return royalFlush;
            }
        
            var getStraightFlush = function(cards) {
                var isExtraCardsExcluded = false;
                var flush = getFlush(cards, isExtraCardsExcluded);
                var straightFlush = flush ? getStraight(flush) : null;

                return straightFlush;
            }

            var getFourofaKind = function(cards) {
                var cardsByRank = {};
                var fourOfaKind = null;
                for (var i = 0; i < cards.length; i++) {
                    var card = cards[i];
                    if (Object.keys(cardsByRank).includes(card.rank)) {
                        cardsByRank[card.rank].push(card);
                        if (cardsByRank[card.rank].length === 4) {
                            fourOfaKind = cardsByRank[card.rank];
                        }
                    }
                    else {
                        cardsByRank[card.rank] = [card];
                    }
                }

                var maxRankingCard = null;
                if (fourOfaKind) {
                    Object.keys(cardsByRank).forEach(rank => {
                        if (maxRankingCard === null && rank !== fourOfaKind[0].rank) {
                            maxRankingCard = cardsByRank[rank][0];
                        }
                        else if (rank !== fourOfaKind[0].rank && getCardScore(rank, true) > maxRankingCard.rank) {
                            maxRankingCard = cardsByRank[rank][0];
                        }
                    });
                }

                var result = fourOfaKind || null;
                if (maxRankingCard) {
                    fourOfaKind = threeOfaKind.concat(maxRankingCard);
                }

                return result;
            }
            
            var getFullHouse = function(cards) {
                var twoOfSameSuit = null;
                var threeOfSameSuit = null;

                if (cards.length >= 5) {
                    var cardsBySuit = {};
                    cards.forEach(card => {
                        if (cardsBySuit[card.suit]) {
                            cardsBySuit[card.suit].push(card);
                        }
                        else {
                            cardsBySuit[card.suit] = [card];
                        }
                    });

                    var suits = Object.keys(cardsBySuit);
                    for (var i = 0; i < suits.length; i++) {
                        if (cardsBySuit[suits[i]].length >= 3) {
                            threeOfSameSuit = cardsBySuit[suits[i]];
                        }
                        else if (cardsBySuit[suits[i]].length >= 2) {
                            if (!twoOfSameSuit || cardsBySuit[suits[i]][0].rank > twoOfSameSuit[0].rank) {
                                twoOfSameSuit = cardsBySuit[suits[i]];
                            }
                        }
                    }
                }

                return twoOfSameSuit && threeOfSameSuit ? threeOfSameSuit.concat(twoOfSameSuit) : null;  
            }

            /** return flush or null if there is none
             * @param isExtraCardsExcluded (opt) - if true, only the highest five cards in the suit 
             *      will be returned. if false, all cards in the matching suit (5-7 cards) will be 
             *      returned.
             */
             getFlush = function(cards, isExtraCardsExcluded = true) {
                var isHand = cards.length >= 5;
                var cardsInSuit = null;

                if (isHand) {
                    var cardsBySuit = {};
                    cards.forEach(card => {
                        if (cardsBySuit[card.suit]) {
                            cardsBySuit[card.suit].push(card);
                        }
                        else {
                            cardsBySuit[card.suit] = [card];
                        }
                    });

                    var suits = Object.keys(cardsBySuit);
                    for (var i = 0; i < suits.length && !cardsInSuit; i++) {
                        if (cardsBySuit[suits[i]].length >= 5) {
                            cardsInSuit = cardsBySuit[suits[i]];
                            if (isExtraCardsExcluded) {
                                var isAceHigh = true;
                                var sortingFunction = generateCardSortingFunction(isAceHigh);
                                cardsInSuit.sort(sortingFunction);
                                cardsInSuit = cardsInSuit.slice(0, 5);
                            }
                        }
                    }
                }

                return cardsInSuit;
            }

            var getStraight = function(cards) {
                var sortingFunction = generateCardSortingFunction(true);
                cards.sort(sortingFunction);

                var straight = [];
                var ace = null;
                for (var i = 0; i < cards.length && straight.length < 5; i++) {
                    if (straight.length === 0) {
                        straight[0] = cards[i];
                    }
                    else if (isNextInStraight(cards, i, straight)) {
                        straight.push(cards[i]);
                    }
                    else if (!isDuplicate(cards, i, straight)) {
                        straight = [cards[i]];
                    }

                    if (cards[i].rank === 'A') {
                        ace = cards[i];
                    }
                }

                if (ace && is2345(straight)) {
                    straight.push(ace);
                }

                var result = straight.length === 5 ? straight : null;
                return result;
            }
            var isNextInStraight = function(cards, i, cardsMatched) {
                // ace high doesn't matter because aces will be logically accounted for
                var lastCardScore = getCardScore(cardsMatched[cardsMatched.length - 1].rank, true);

                return getCardScore(cards[i].rank, true) === lastCardScore - 1;
            }
            var isDuplicate = function(cards, i, cardsMatched) {
                // ace high doesn't matter because aces will be logically accounted for
                var lastCardScore = getCardScore(cardsMatched[cardsMatched.length - 1].rank, true);

                return getCardScore(cards[i].rank, true) === lastCardScore;
            }
            var is2345 = function(cards) {
                var numberOfMatches = 0;
                if (cards.length === 4) {
                    for (var i = 0; i < cards.length && numberOfMatches < 4; i++) {
                        var card = cards[i];
                        if (card.rank === '2' || card.rank === '3' || card.rank === '4' || card.rank === '5') {
                            numberOfMatches++;
                        }
                    }
                }

                return numberOfMatches === 4;
            }
            
            var getThreeofaKind = function(cards) {
                var cardsByRank = {};
                var threeOfaKind = null;
                for (var i = 0; i < cards.length; i++) {
                    var card = cards[i];
                    if (Object.keys(cardsByRank).includes(card.rank)) {
                        cardsByRank[card.rank].push(card);
                        if (cardsByRank[card.rank].length === 4) {
                            threeOfaKind = cardsByRank[card.rank];
                        }
                    }
                    else {
                        cardsByRank[card.rank] = [card];
                    }
                }

                var maxRankingCard1 = null;
                var maxRankindCard2 = null;
                if (threeOfaKind) {
                    Object.keys(cardsByRank).forEach(rank => {
                        if (maxRankingCard1 === null && rank !== threeOfaKind[0].rank) {
                            maxRankingCard1 = cardsByRank[rank][0];
                        }
                        else if (maxRankingCard2 === null && rank !== threeOfaKind[0].rank) {
                            maxRankingCard2 = cardsByRank[rank][0];
                        }

                        if (rank !== threeOfaKind[0].rank && getCardScore(rank, true) > maxRankingCard1.rank) {
                            maxRankingCard1 = cardsByRank[rank][0];
                        }
                        else if (rank !== threeOfaKind[0].rank && getCardScore(rank, true) > maxRankingCard2.rank) {
                            maxRankingCard2 = cardsByRank[rank][0];
                        }
                    });
                }

                var result = threeOfaKind || null;
                if (maxRankingCard1) {
                    threeOfaKind = threeOfaKind.concat(maxRankingCard1);
                }
                if (maxRankindCard2) {
                    threeOfaKind = threeOfaKind.concat(maxRankindCard2);
                }

                return result;
            }

            var getTwoPair = function(cards) {
                var isAceHigh = true;
                var sortingFunction = generateCardSortingFunction(isAceHigh);
                cards.sort(sortingFunction);

                var pair1 = [];
                var pair2 = [];
                var highCard = null;
                var cardsByRank = {};

                for (var i = 0; i < cards.length; i++) {
                    if (cardsByRank.includes(cards[i].rank)) {
                        cardsByRank[cards[i].rank].push(cards[i]);
                    }
                    else {
                        cardsByRank[cards[i].rank] = [cards[i]];
                    }
                }

                Object.keys(cardsByRank).forEach(rank => {
                    var isMatch = false;

                    if (cardsByRank[rank].length >= 2) {
                        if (pair1 === null || getCardScore(pair1[0].rank) < getCardScore(rank)) {
                            isMatch = true;
                            pair1 = cardsByRank[rank].slice(0, 2);
                        }
                        else if (pair2 === null || getCardScore(pair2[0].rank) < getCardScore(rank)) {
                            isMatch = true;
                            pair2 = cardsByRank[rank].slice(0, 2);
                        }

                        
                    }

                    if ((!isMatch || cardsByRank[rank].length > 2) && getCardScore(highCard.rank) < getCardScore(cardsByRank[rank][0].rank)) {
                        highCard = isMatch ? cardsByRank[rank][2] : cardsByRank[rank][0];
                    }
                });

                return (pair1.length === 2 && pair2.length === 2) ? pair1.concat(pair2).concat(highCard) : null;
            }

            var getPair = function(cards) {
                var isAceHigh = true;
                var sortingFunction = generateCardSortingFunction(isAceHigh);
                cards.sort(sortingFunction);

                var pair = [];
                var highCards = [];
                var cardsByRank = {};

                for (var i = 0; i < cards.length; i++) {
                    if (cardsByRank.includes(cards[i].rank)) {
                        cardsByRank[cards[i].rank].push(cards[i]);
                    }
                    else {
                        cardsByRank[cards[i].rank] = [cards[i]];
                    }
                }

                Object.keys(cardsByRank).forEach(rank => {
                    var isMatch = false;

                    if (cardsByRank[rank].length >= 2) {
                        if (pair === null || getCardScore(pair[0].rank) < getCardScore(rank)) {
                            isMatch = true;
                            pair = cardsByRank[rank].slice(0, 2);
                        }
                    }

                    var cardsToAdd = [];
                    if (cardsByRank[rank].length > 2) {
                        cardsToAdd = cardsByRank[rank].slice(2, cardsByRank[rank].length); 
                    }
                    else if (!isMatch) {
                        cardsToAdd = cardsByRank[rank];
                    }

                    if (highCards.length >= 3) {
                        highCards.sort(sortingFunction);
                        var isHighCard = false;
                        for (var i = 0; i < highCards.length && !isHighCard; i++) {
                            var highCard = highCards[i];
                            if (getCardScore(cardsToAdd[0].rank) > getCardScore(highCard.rank)) {
                                highCards[i] = cardsToAdd[0];
                                isHighCard = true;
                            }
                        }
                    }
                    else {
                        var index = 0;
                        do {
                            highCards.push(cardsToAdd[index]);
                        } while (highCards.length < 3);
                    }
                });
                return (pair.length === 2) ? pair.concat(highCard) : null;
            }

            // smaller index equals higher ranked card
            var getHighCardAtIndex = function(cards, index) {
                var isAceHigh = true;
                var sortFunction = generateCardSortingFunction(isAceHigh);
                cards.sort(sortFunction);
                return cards[index];
            }

            var generateCardSortingFunction = function(isAceHigh, isAscending = false) {
                return function(a, b) {
                    var sortResult = 0;

                    if (isAscending) {
                        sortResult = getCardScore(a.rank, isAceHigh) - getCardScore(b.rank, isAceHigh);
                    }
                    else {
                        sortResult = getCardScore(b.rank, isAceHigh) = getCardScore(a.rank, isAceHigh);
                    }

                    return sortResult;
                };
            }

            var getCardScore = function(cardRank, isAceHigh = true) {
                var aceScore = isAceHigh ? 14 : 1;
                var cardRanks = {
                    'A': aceScore,
                    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 1, '8': 8,
                    '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
                };
                return cardRanks[cardRank];
            }

            // return { hand: [<card>], score: 1-10 (10 is highest ) }
            var getHandAndScore = function(cards) {
                var hand = null;
                var score = 10;

                var handCheckFunctions = [
                    getRoyalFlush,
                    getStraightFlush,
                    getFourofaKind,
                    getFullHouse,
                    getFlush,
                    getStraight,
                    getThreeofaKind,
                    getTwoPair,
                    getPair
                ];
                for (var i = 0; i < handCheckFunctions.length && !hand; i++) {
                    var tryMatchHand = handCheckFunctions[i];
                    hand = tryMatchHand(cards);
                    
                    if (!hand) {
                        score--;
                    }
                }

                if (!hand) {
                    hand = (cards.length > 5) ? cards.slice(0, 5) : cards;
                }
                return { hand, score };
            }
        </script>

        <!-- turn-taking logic -->
        <script>
            var cardsOnTable = []

            var setUserActions = function() {
                document.getElementById('button-call-check').onclick = function() {
                    var actionType = isCheck() ? 'check' : 'call';
                    onNextUserAction(actionType); 
                }

                document.getElementById('button-raise-bet').onclick = function() {
                    if (isBet()) {
                        showBetAmountDialog();
                    }
                    else {
                        onNextUserAction('raise');
                    }
                }

                document.getElementById('button-fold').onclick = function() {
                    onNextUserAction('fold');
                }
            }

            /** actionType: 'check', 'call', 'bet', 'raise', 'fold'
            /* actionValue (any): bet (number)
            */
            var onNextUserAction = function(actionType, actionValue) {
                var activePlayer = players[currentTurnIndex]; 

                switch (actionType) {
                    case 'check': 
                        break;
                    case 'call': 
                        currentPotAmount += currentBet;
                        activePlayer.currentBet += currentBet;
                        activePlayer.numberOfChips -= currentBet;
                        break;
                    case 'bet': 
                        currentPotAmount += actionValue;
                        activePlayer.numberOfChips -= actionValue;
                        activePlayer.currentBet = actionValue;
                        currentBet = actionValue;
                        break;
                    case 'raise': 
                        currentPotAmount += 2 * currentBet;
                        activePlayer.numberOfChips -= 2 * currentBet;
                        activePlayer.currentBet += 2 * currentBet;
                        break;
                    case 'fold':
                        activePlayer.card1 = null;
                        activePlayer.card2 = null;
                        break;
                }

                endTurn();
            }

            var incrementTurnIndex = function() {
                currentTurnIndex = (currentTurnIndex + 1) % players.length;
            }

            var isOnePlayerLeft = function() {
                var playersIn = players.filter(player => {
                    return player.card1 !== null && player.card1 !== undefined;
                });
                return playersIn.length === 1;
            }

            var startNextTurn = function() {
                if (currentTurnIndex === currentPlayerIndex) {
                    showCallCheckButton();
                    showRaiseBetButton();
                    showFoldButton();
                }
                // todo: else if human player then wait for their turn. 
                //      then, use events to update chip counts and actions for other players (add chips, bet/raise)
                else { // todo: get rid of this (move hideButtons to end of user turn? and remove beginAiTurn because server will handle AI and player sockets)
                    hideButtons();
                    beginAiTurn(); // todo: implement this
                }
            }

            var numberOfRounds = 4; // pre-flop, flop, turn, river
            var roundNumber = 1;
            var endTurn = function() {
                numberOfTurnsPlayed++;
                var isRoundComplete = isOnePlayerLeft() || (numberOfTurnsPlayed >= players.length && areAllBetsEqual());

                if (isRoundComplete) {
                    numberOfTurnsPlayed = 0;

                    if (currentRoundIndex === numberOfRounds) {
                        var winningPlayerRewards = determineWinningAmountsByPlayerIndex();
                        winningPlayerRewards.forEach(reward => {
                            players[reward.playerIndex].numberOfChips += reward.winningAmount;
                        });

                        players.forEach(player => {
                            if (player.numberOfChips <= 0) {
                                // boot player, or let player add chips until their turn?
                            }
                        })

                        cardsOnTable = [];
                        beginDeal(function() {
                            startNextTurn();
                        });
                    }
                    else {
                        roundNumber++;
                        drawCardFromDeck(); // burn card

                        if (roundNumber === 2) { // flop
                            var timeout = 0;
                            for (var i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    cardsOnTable.push(drawCardFromDeck());
                                }, timeout);
                                timeout += 250;
                            }
                        }
                        else {
                            cardsOnTable.push(drawCardFromDeck());
                        }
                    }
                }
                else {
                    do {
                        incrementTurnIndex();
                    } while (!players[currentTurnIndex].card1);

                    startNextTurn();
                }
            }

            var ROYAL_FLUSH_RANK = 10;
            var STRAIGHT_FLUSH_RANK = 9;
            var FOUR_OF_A_KIND_RANK = 8;
            var FULL_HOUSE_RANK = 7;
            var FLUSH_RANK = 6;
            var STRAIGHT_RANK = 5;
            var THREE_OF_A_KIND_RANK = 4;
            var TWO_PAIR_RANK = 3;
            var PAIR_RANK = 2;
            var HIGH_CARD_RANK = 1;
            /** returns [{ playerIndex, winningAmount }] */
            var determineWinningAmountsByPlayerIndex = function() {
                var winners = [];
                var highestRank = 0;
                var isAceHighByPlayerName = {};

                players.forEach(player => {
                    if (player.card1 && player.card2) {
                        var allCards = cardsOnTable.concat(player.card1).concat(player.card2);
                        var hand = getHandAndScore(allCards);

                        if (hand.score === highestRank) {
                            winners.push(player);
                        }
                        else if (hand.score > highestRank) {
                            highestRank = hand.score;
                            winners = [player];
                        }

                        if (hand.score >= highestRank && [STRAIGHT_FLUSH_RANK, STRAIGHT_FLUSH_RANK].includes(hand.score)) {
                            var athrough5 = ['A', '2', '3', '4', '5'];
                            for (var i = 0; i < hand.hand.length; i++) {
                                var isMatch = false;
                                for (var j = 0; j < athrough5 && !isMatch; j++) {
                                    if (hand.hand[i].rank === athrough5[j]) {
                                        isMatch = true;
                                        athrough5 = athrough5.slice(j, 1);
                                    }
                                }
                            }
                            isAceHighByPlayerName[player.name] = athrough5.length > 0;
                        }
                    }
                });

                var winningAmountsByPlayerIndex = null;
                if (winners.length > 1) {
                    // if royal then just split the pot because everybody's a winner
                    if ([STRAIGHT_FLUSH_RANK, STRAIGHT_RANK, FLUSH_RANK].includes(highestRank)) {
                        var highCardWinners = [];
                        var highCardScore = 0;

                        winners.forEach(winner => {
                            var allCards = cardsOnTable.concat(player.card1).concat(player.card2);
                            var isAceHigh = isAceHighByPlayerName[winner.name];
                            var sortedCards = allCards.sort(generateCardSortingFunction(isAceHigh));
                            
                            var highCard = sortedCards[0];
                            var cardScore = getCardScore(highCard.rank, isAceHigh);
                            if (cardScore > highCardScore) {
                                highCardScore = cardScore;
                                highCardWinners = [winner];
                            }
                            else if (cardScore === highCardScore) {
                                highCardWinners.push(winner);
                            }
                        });
                        winners = highCardWinners;
                    }
                    else if (highestRank === FOUR_OF_A_KIND_RANK) {
                        winners = getNofaKindWinners(winners, 4);
                    }
                    else if (highestRank === FULL_HOUSE_RANK) {
                        var highestThreeRank;
                        var highestTwoRank;
                        var highestThreeWinners;
                        var highestTwoWinners;

                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var cardsByRank = groupBy(hand, 'rank');
                            Object.keys(cardsByRank).forEach(rank => {
                                var cards = cardsByRank[rank];
                                var cardScore = getCardScore(rank);
                                if (cards.length === 3) {
                                    if (cardScore > highestThreeRank) {
                                        highestThreeRank = cardScore;
                                        highestThreeWinners = [winner];
                                    }
                                    else if (cardScore === highestThreeRank) {
                                        highestThreeWinners.push(winner);
                                    }
                                }
                                else if (cards.length === 2) {
                                     if (cardScore > highestTwoRank) {
                                         highestTwoRank = cardScore;
                                         highestTwoWinners = [winner];
                                     }
                                     else if (cardScore === highestTwoRank) {
                                         highestTwoWinners.push(winner);
                                     }
                                }
                            });
                        });

                        if (highestThreeWinners.length === 1 || highestTwoWinners.length > 1) {
                            winners = highestThreeWinners;
                        }
                        else {
                            winners = highestTwoWinners;
                        }
                    }
                    else if (highestRank === THREE_OF_A_KIND_RANK) {
                        winners = getNofaKindWinners(winners, 3);
                    }
                    else if (highestRank === TWO_PAIR_RANK) {
                        var highestPair1Score = 0;
                        var highestPairWinners = [];
                        var highestPair2Score = 0;
                        var highCardScore = 0;

                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var cardsByRank = groupBy(hand, 'rank');
                            var highestPairScore = 0;
                            var secondHighestPairScore = 0;
                            var highestCardScore = 0;

                            Object.keys(cardsByRank).forEach(rank => { 
                                var cardScore = getCardScore(rank);
                                if (cardsByRank[rank].length === 2) {
                                    if (cardScore > highestPairScore) {
                                        highestPairScore = cardScore;
                                    }
                                    else if (cardScore > secondHighestPairScore) {
                                        secondHighestPairScore = cardScore;
                                    }
                                    else if (cardScore > highestCardScore) {
                                        highestCardScore = cardScore;
                                    }
                                }
                                else if (cardScore > highestCardScore) { // must be single card cuz 3+ would automatically be a better hand
                                    highestCardScore = cardScore;
                                }
                            });

                            if (highestPairScore > highestPair1Score) {
                                highestPair1Score = highestPairScore;
                                highestPair2Score = secondHighestPairScore;
                                highCardScore = highestCardScore;
                                highestPairWinners = [winner];
                            }
                            else if (highestPairScore === highestPair1Score) {
                                if (secondHighestPairScore > highestPair2Score) {
                                    highestPair1Score = highestPairScore;
                                    highestPair2Score = secondHighestPairScore;
                                    highCardScore = highestCardScore;
                                    highestPairWinners = [winner];
                                }
                                else if (secondHighestPairScore === highestPair2Score) {
                                    if (highestCardScore > highCardScore) {
                                        highestPair1Score = highestPairScore;
                                        highestPair2Score = secondHighestPairScore;
                                        highCardScore = highestCardScore;
                                        highestPairWinners = [winner];
                                    }
                                    else if (highestCardScore === highCardScore) {
                                        highestPairWinners.push(winner);
                                    }
                                }
                            }
                        });

                        winners = highestPairWinners;
                    }
                    else if (highestRank === PAIR_RANK) {
                        var highPairScore = 0;
                        var highPairWinners = [];
                        var highCardScores = []; // highest cards in desc order

                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var cardsByRank = groupBy(hand, 'rank');
                            var highestPairScore = 0;
                            var highestCardScores = [];

                            Object.keys(cardsByRank).forEach(rank => { 
                                var cardScore = getCardScore(rank);
                                if (cardsByRank[rank].length === 2 && cardScore > highestPairScore) {
                                    highestPairScore = cardScore;
                                }
                                else { // must be single card cuz 3+ would automatically be a better hand
                                    if (highestCardScores.length < 3) {
                                        highestCardScores.push(cardScore);
                                        if (highestCardScores.length === 3) {
                                            highestCardScores.sort((a, b) => { return b - a; });
                                        }
                                    }
                                    else {
                                        var swappedScore = null;
                                        for (var i = 0; i < highestCardScores.length; i++) {
                                            if (swappedScore) {
                                                var tempScore = highestCardScores[i];
                                                highestCardScores[i] = swappedScore;
                                                swappedScore = tempScore;
                                            }
                                            else if (cardScore > highestCardScores[i]) {
                                                swappedScore = highestCardScores[i]
                                                highestCardScores[i] = cardScore;
                                            }
                                        }
                                    }
                                }
                            });

                            if (highestPairScore > highPairScore) {
                                highPairScore = highestPairScore;
                                highPairWinners = [winner];
                                highCardScores = highestCardScores;
                            }
                            else if (highestPairScore === highPairScore) {
                                var isTied = true;
                                for (var i = 0; i < highCardScores.length && isTied; i++) {
                                    if (highestCardScores[i] > highCardScores[i]) {
                                        highPairWinners = [winner];
                                        highCardScores = highestCardScores;
                                        isTied = false;
                                    }
                                    else {
                                        isTied = highestCardScores[i] === highCardScores[i];
                                    }
                                }

                                if (isTied) {
                                    highPairWinners.push(winner);
                                }
                            }
                        });

                        winners = highPairWinners;
                    }
                    else if (highestRank === HIGH_CARD_RANK) { // high card
                        var highCardScores = [];
                        var highCardWinners = [];

                        var finalWinners = [];
                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var sortedHand = hand.sort(generateCardSortingFunction(true));
                            var cardScores = sortedHand.map(card => {
                                return getCardScore(card.rank, true);
                            });

                            if (highCardScores.length === 0) {
                                highCardScores = cardScores;
                                highCardWinners = [winner];
                            }
                            else {
                                var isReplaced = false;
                                var isEqual = true;
                                for (var i = 0; i < cardScores.length && !isReplaced; i++) {
                                    isReplaced = cardScores[i] > highCardScores[i];
                                    isEqual = cardScores[i] === highCardScores[i];
                                }

                                if (isReplaced) {
                                    highCardScores = cardScores;
                                    highCardWinners = [winner];
                                }
                                else if (isEqual) {
                                    highCardWinners.push(winner);
                                }
                            }

                            finalWinners = highCardWinners;
                        });
                        winners = finalWinners;
                    }
                
                    winningAmountsByPlayerIndex = getWinningAmountsByPlayerIndex(winners);
                }
                else { // single winner
                    var winningIndex;
                    var isIndexFound = false;
                    for (var i = 0; i < players.length && !isIndexFound; i++) {
                        if (players[i].name === winners[0].name) {
                            winningIndex = i;
                            isIndexFound = true;
                        }
                    }

                    winningAmountsByPlayerIndex = [{
                        playerIndex: winningIndex,
                        winningAmount: currentPotAmount
                    }];
                }

                return winningAmountsByPlayerIndex;
            }

            var getNofaKindWinners = function(players, n) {
                var highestNScore = 0;
                var highestNWinners = [];

                var winners = [];
                players.forEach(winner => {
                    var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                    var cardsByRank = groupBy(hand, 'rank');
                    var nOfakindCard;
                    var ranks = Object.keys(cardsByRank);
                    for (var i = 0; i < ranks.length && !nOfakindCard; i++) {
                        if (cardsByRank[ranks[i]].length === n) {
                            nOfakindCard = cardsByRank[ranks[i]][0];
                        }
                    }

                    var cardScore = getCardScore(nOfakindCard.rank, true);
                    if (cardScore > highestNScore) {
                        highestNScore = cardScore;
                        highestNWinners = [winner];
                    }
                    else if (cardScore === highestNScore) {
                        highestNWinners.push(winner);
                    }
                });

                if (highestNWinners.length > 1) {
                    var highestCardWinners = []
                    var highestCardScore = 0;

                    players.forEach(winner => {
                        var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                        var cardsByRank = groupBy(hand, 'rank'); 
                        var ranks = Object.keys(cardsByRank);
                        var highCardScore = 0;
                        for (var i = 0; i < ranks.length; i++) {
                            if (cardsByRank[ranks[i]].length < n) {
                                highCardScore = Math.max(highCardScore, getCardScore(cardsByRank[ranks[i]][0].rank));
                            }
                        }

                        if (highCardScore > highestCardScore) {
                            highestCardScore = highCardScore;
                            highestCardWinners = [winner];
                        }
                        else if (highCardScore === highestCardScore) {
                            highestCardWinners.push(winner);
                        }
                    });

                    winners = highestCardWinners;
                }
                else {
                    winners = highestNWinners;
                }

                return winners;
            }

            // return [{ playerIndex, winningAmount }]
            var getWinningAmountsByPlayerIndex = function(winners) {
                var winningAmountsByPlayerIndex = [];
                var winningNames = winners.map(function(winner) { return winner.name });
                for (var i = 0; i < players.length; i++) {
                    if (winningNames.includes(player[i].name)) {
                        winningAmountsByPlayerIndex.push({
                            playerIndex: i,
                            winningAmount: parseInt(currentPotAmount / winners.length)
                        });
                    }
                }
            }

            var groupBy = function(items, propertyName) {
                var groups = {};
                items.forEach(item => {
                    if (groups[item[propertyName]]) {
                        groups[item[propertyName]].push(item);
                    }
                    else {
                        groups[item[propertyName]] = [item];
                    }
                });

                return groups;
            }
        </script>

        <!-- Base logic function (draw, update) -->
        <script>
            var draw = function(canvas) {
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                var tableStart = parseInt(canvas.width * 0.2);
                var tableWidth = parseInt(canvas.width * 0.65);
                var tableHeight = parseInt(canvas.height * 0.25);

                drawTable(ctx, tableStart, tableStart, tableWidth, tableHeight);
                drawPlayers(ctx, getPlayers(), tableStart, tableWidth, tableHeight);

                if (currentPlayerIndex === 0 || currentPlayerIndex) {
                    drawUserHand(ctx, canvas);
                }

                if (areBlindsSet()) {
                    drawBlinds(ctx, tableStart, tableWidth, tableHeight);
                }
                drawPlayerHands(ctx, tableStart, tableWidth, tableHeight);

                drawCardsOnTable(ctx, tableStart, tableWidth, tableHeight);
            }
        </script>

        <script>
            var players = [];
            var currentPlayerIndex;

            window.onload = function() {
                setUserActions();

                /// GAME READY/INIT
                document.addEventListener("message", function(event) {
                    var messageData = JSON.parse(event.data);
                    players = messageData.players;
                    currentPlayerIndex = messageData.currentPlayerIndex || 0;

                    bigBlindAmount = 10;
                    littleBlindAmount = 5;

                    beginDeal(function() {
                        startNextTurn();
                    });
                });

                var canvas = document.getElementById('tableCanvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                var canvasRect = canvas.getBoundingClientRect();

                loadSpritesConfig();
                loadButtons(canvasRect.left, canvasRect.top, canvas.width, canvas.height);

                setInterval(function() {
                    draw(canvas);
                }, 1000 / 24);
            }
        </script>

        
    </body>
</html>