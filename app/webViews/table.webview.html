<html>
    <head></head>
    <body style="background-color: #dedede">
        <div style="text-align: center">
            <div id="message-container" onclick="messageBoxDropdownClick()">
                <div id="message-box" class="message-box-container"></div>
                <div id="message-box-dropdown-icon" class="arrow-down"></div>
            </div>
            <div id="message-list-box"></div>
        </div>
        <div style="text-align: center">
            <button id="button-call-check" class="game-button during-hand-button">none</button>
            <button id="button-raise-bet" class="game-button during-hand-button">none</button>
            <button id="button-fold" class="game-button during-hand-button">Fold</button>
            <button id="button-show-cards" class="game-button after-hand-button">Show Cards</button>
            <button id="button-muck" class="game-button after-hand-button">Muck</button>
        </div>
        <div id="modal-overlay"></div>
        <div id="bet-amount-dialog">
            <p>Enter amount:</p>
            <input id="bet-amount" type="number" />
            <div id="bet-button-holder">
                <button id="cancel-button" class="bet-dialog-button" onclick="hideBetAmountDialog()">Cancel</button>
                <button id="bet-button" class="bet-dialog-button" onclick="onUserPlaceBet()">none</button>
            </div>
        </div>
        <canvas id="tableCanvas" width="100%" height="100%"></canvas>
        <style>
            #tableCanvas {
                margin-top: 0.5em;
            }

            .game-button {
                position: absolute;
                z-index: 998;
                padding: 0.35em 1em;
                font-size: 1.25em;
                display: none;
                color: white;
                font-weight: bold;
                border: none;
            }
            .during-hand-button {
                width: 7em;
            }
            .after-hand-button {
                width: 7.5em;
                background-color: #0808FF;
            }

            #modal-overlay {
                position: absolute;
                z-index: 999;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: none;
            }

            #bet-amount-dialog {
                position: absolute;
                z-index: 1000;
                padding: 0 1em 1em 1em;
                display: none;
                background-color: #444;
                text-align: center;
            }
            #bet-amount-dialog p {
                color: white;
                font-size: 1.15em;
                margin-bottom: 0.25em;
            }
            #bet-button-holder {
                text-align: center;
            }
            .bet-dialog-button {
                border: none;
                color: white;
                margin-top: 0.5em;
                font-weight: bold;
                font-size: 1.3em;
                padding: 0.25em;
                width: 3.5em;
            }
            #bet-button {
                background-color: #117711;
                margin-left: 0.5em;
            }
            #cancel-button {
                background-color: #991111;
            }

            #button-call-check {
                background-color: #0808FF;
            }
            #button-raise-bet {
                background-color: #117711;
            }
            #button-fold {
                background-color: #991111;
            }

            #bet-amount {
                font-size: 1.2em;
            }

            .message-box-container {
                text-align: center;
                margin-bottom: 0;
                padding: 0.25em 0;
                border: 1px solid #888;
                min-height: 1em;
                font-size: 1.25em;
                background-color: #efefef;
                width: 80%;
            }
            .message-box-item {
                padding: 0.25em 0 0.25em 0.25em;
                border-bottom: 1px solid #888;
            }

            .arrow-down {
                width: 0; 
                height: 0; 
                border-left: 20px solid transparent;
                border-right: 20px solid transparent;
                
                border-top: 20px solid #333;
            }
            .arrow-up {
                width: 0; 
                height: 0; 
                border-left: 20px solid transparent;
                border-right: 20px solid transparent;
                
                border-bottom: 20px solid #333;
            }

            #message-container > div {
                display: inline-block;
            }

            #message-box-dropdown-icon {
                position: relative;
                top: 0.25em;
            }

            #message-list-box {
                position: absolute;
                left: 5%;
                z-index: 999;
                background-color: #eee;
                width: 80%;
            }
        </style>

        <!-- Utility drawing functions, e.g. rounded rect, circle, etc -->
        <script>
            var maxMessageCount = 20;
            var lastMessages = [];
            var isMessageListDisplayed = false;
            var setMessageText = function(text) {
                lastMessages.push(text);
                if (lastMessages.length > maxMessageCount) {
                    lastMessages = lastMessages.slice(1, maxMessageCount + 1);
                }

                if (isMessageListDisplayed) {
                    var messageListBox = document.getElementById('message-list-box');
                    messageListBox.innerHTML = '';
                    appendMessagesToView(messageListBox);
                }
                else {
                    document.getElementById('message-box').innerHTML = text;
                }
            }

            var messageBoxDropdownClick = function() {
                isMessageListDisplayed = !isMessageListDisplayed;
                var messageListBox = document.getElementById('message-list-box');

                var dropdownIcon = document.getElementById('message-box-dropdown-icon');
                dropdownIcon.classList.remove('arrow-up', 'arrow-down');
                var updatedClass = isMessageListDisplayed ? 'arrow-up' : 'arrow-down';
                dropdownIcon.classList.add(updatedClass);

                if (isMessageListDisplayed) {
                    appendMessagesToView(messageListBox);
                }
                else {
                    messageListBox.innerHTML = '';
                }

                messageListBox.style.display = isMessageListDisplayed ? 'inline-block' : 'none';
            }
            var appendMessagesToView = function(messageListBox) {
                for (var i = lastMessages.length - 1; i >= 0; i--) {
                    if (i === lastMessages.length - 1) {
                        document.getElementById('message-box').innerHTML = lastMessages[i];
                    }
                    else {
                        var messageElement = document.createElement('div');
                        messageElement.innerHTML = lastMessages[i];
                        messageElement.classList.add('message-box-item');
                        messageListBox.appendChild(messageElement);
                    }
                }
            }

            /** https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas */
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke == 'undefined') {
                    stroke = true;
                }
                if (typeof radius === 'undefined') {
                    radius = 5;
                }
                if (typeof radius === 'number') {
                    radius = {tl: radius, tr: radius, br: radius, bl: radius};
                } else {
                    var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
                    for (var side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                    }
                }
                ctx.beginPath();
                ctx.moveTo(x + radius.tl, y);
                ctx.lineTo(x + width - radius.tr, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                ctx.lineTo(x + width, y + height - radius.br);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                ctx.lineTo(x + radius.bl, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                ctx.lineTo(x, y + radius.tl);
                ctx.quadraticCurveTo(x, y, x + radius.tl, y);
                ctx.closePath();
                if (fill) {
                    ctx.fill();
                }
                if (stroke) {
                    ctx.stroke();
                }

            }

            function circle(ctx, centerX, centerY, radius, fillStyle, strokeStyle, lineWidth) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = fillStyle;
                ctx.fill();
                ctx.lineWidth = lineWidth || 3;
                ctx.strokeStyle = strokeStyle;
                ctx.stroke();
            }
        </script>

        <!-- Handle data from React Native -->
        <script>
            var handleMessageFromApp = function(event) {
                // var messageData = JSON.parse(event.data);
                // alert("name: " + messageData.name);
                alert("hmmmm ")
            };
        </script>

        <!-- Get data for game -->
        <script>
            var getAvatarColor = function(playerNumber) {
                var colors = [
                    'purple',
                    'yellow',
                    'blue',
                    'orange',
                    'green',
                    'red',
                    'brown',
                    'pink'
                ];
                return colors[playerNumber - 1];
            }

            var getPlayerDeckLocation = function(playerIndex, tableX, tableY, tableWidth, tableHeight) {
                var deckLocation = {};

                switch (playerIndex) {
                    case 0: 
                        deckLocation = {
                            x: tableX + 20,
                            y: tableY + (tableHeight * 0.5) + 10
                        };
                        break;
                    case 1: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.25),
                            y: tableY + 20
                        };
                        break;
                    case 2: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.5),
                            y: tableY + 20
                        };
                        break;
                    case 3: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.75),
                            y: tableY + 20
                        };
                        break;
                    case 4: 
                        deckLocation = {
                            x: tableX + tableWidth - 20,
                            y: tableY + (tableHeight * 0.5) - 15
                        };
                        break;
                    case 5: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.75),
                            y: tableY + tableHeight - 28
                        };
                        break;
                    case 6: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.5),
                            y: tableY + tableHeight - 28
                        };
                        break;
                    case 7: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.25),
                            y: tableY + tableHeight - 28
                        };
                        break;
                }

                return deckLocation;
            }
        </script>

        <!-- Config data, e.g. sprite image locations -->
        <script>
            var cardsSprite;
            var spritesLocations;
            var spriteWidth;
            var spriteHeight;

            var suitsSprite;

            var loadButtons = function(canvasX, canvasY, canvasWidth, canvasHeight) {
                var buttonsLeft = canvasX + parseInt(canvasWidth * 0.5);

                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.style.top = canvasY + parseInt(canvasHeight * 0.6);
                callCheckButton.style.left = buttonsLeft;

                var raiseBetButton = document.getElementById('button-raise-bet');
                raiseBetButton.style.top = canvasY + parseInt(canvasHeight * 0.7);
                raiseBetButton.style.left = buttonsLeft;

                var foldButton = document.getElementById('button-fold');
                foldButton.style.top = canvasY + parseInt(canvasHeight * 0.8);
                foldButton.style.left = buttonsLeft;

                var showCardsButton = document.getElementById('button-show-cards');
                showCardsButton.style.top = canvasY + parseInt(canvasHeight * 0.6);
                showCardsButton.style.left = buttonsLeft;

                var muckButton = document.getElementById('button-muck');
                muckButton.style.top = canvasY + parseInt(canvasHeight * 0.7);
                muckButton.style.left = buttonsLeft;
            }

            var loadDialogs = function(canvasX, canvasY, canvasWidth, canvasHeight) {
                var betDialogLeft = canvasX + parseInt(canvasWidth * 0.05);
                var betDialogTop = canvasY + parseInt(canvasHeight * 0.25);
                var betDialog = document.getElementById('bet-amount-dialog');
                betDialog.style.left = betDialogLeft;
                betDialog.style.top = betDialogTop;
                betDialog.style.width = parseInt(canvasWidth * 0.75);
            }

            var loadSpritesConfig = function() {
                cardsSprite = new Image();
                cardsSprite.src = 'https://i.ibb.co/ZB85jHT/card-deck-161536-1280.png';

                suitsSprite = new Image();
                suitsSprite.src = 'https://i.ibb.co/R4X28Nd/suits.png';
                
                var numberOfColumns = 13;
                var numberOfRows = 5;
                var widthPerColumn = spriteWidth = cardsSprite.width / numberOfColumns;
                var heightPerColumn = spriteHeight =  cardsSprite.height / numberOfRows;

                spritesLocations = {};
                var ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                var suits = ['Clubs', 'Diamonds', 'Hearts', 'Spades'];
                for (var rank = 0; rank < ranks.length; rank++) {
                    for (var suit = 0; suit < suits.length; suit++) {
                        var x = rank * widthPerColumn;
                        var y = suit * heightPerColumn;
                        var rankName = ranks[rank];
                        var suitName = suits[suit];
                        
                        if (suit === 0) {
                            spritesLocations[rankName] = {};
                        }
                        spritesLocations[rankName][suitName] = { x, y };
                    }
                }
            }

            var userOutlineInterval;
            var animateUserOutline = function() {
                userOutlineInterval = setInterval(() => {
                    userOutlineColor = (userOutlineColor === 'white') ? 'black' : 'white';
                }, 750);
            }
            var stopUserOutlineAnimation = function() {
                if (userOutlineInterval) {
                    clearInterval(userOutlineInterval);
                    userOutlineColor = 'black';
                    userOutlineInterval = null;
                }
            }

            var suitSpriteLocations = {
                'spade': {
                    getX: function() { return 0; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'heart': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'diamond': {
                    getX: function() { return 0; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'club': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                }
            }
        </script>

        <!-- Load data from external source -->
        <script>
            
            
        </script>

        <!-- Draw functions -->
        <script>
            var drawTable = function(ctx, x, y, width, height) {
                var radius = 50;
                ctx.fillStyle = "#046908";
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 5;
                roundRect(ctx, x, y, width, height, radius, true);
            }

            var drawPlayerInfo = function(ctx, text, x, y, yOffset) {
                var xOffset = 5 - parseInt(text.length * 3.5);
                var finalX = x + xOffset
                var finalY = y + yOffset
                ctx.fillStyle = 'black';
                ctx.fillText(text, finalX, finalY);
            }

            var userOutlineColor = 'black'; // interval exists to alternate colors
            var drawPlayer = function(ctx, players, playerNumber, x, y, radius) {
                var color = players && players.length >= playerNumber ? getAvatarColor(playerNumber) : 'grey';
                var outlineColor = 'black';
                var playerIndex = playerNumber - 1;
                if (playerIndex === currentPlayerIndex) {
                    outlineColor = userOutlineColor;
                }
                else if (playerIndex === game.currentTurnIndex) {
                    outlineColor = 'white';
                }
                circle(ctx, x, y, radius, color, outlineColor);

                var isPlayerInSeat = players && players.length >= playerNumber;
                var playerName = isPlayerInSeat ? players[playerNumber - 1].name : '[Empty]';
                drawPlayerInfo(ctx, playerName, x, y + radius, 12);
                if (isPlayerInSeat) {
                    var playerWorth = players[playerNumber - 1].numberOfChips || 0;
                    drawPlayerInfo(ctx, playerWorth.toString(), x - 5, y + radius, 25);
                }
            }

            var drawPlayers = function(ctx, players, tableX, tableY, tableWidth, tableHeight) {
                var avatarRadius = parseInt(tableWidth / 11);

                var avatarX_left = parseInt(tableX * 0.5);
                var avatarX_center_left = parseInt(tableX + (0.2 * tableWidth));
                var avatarX_center = parseInt(tableX + (0.5 * tableWidth));
                var avatarX_center_right = parseInt(tableX + (0.8 * tableWidth));
                var avatarX_right = parseInt(tableX + (tableWidth * 1.15));

                var avatarY_top = parseInt(tableY * 0.33);
                var avatarY_center = parseInt(tableY + (0.5 * tableHeight));
                var avatarY_bottom = parseInt(tableY + tableHeight + (0.4 * tableY));

                ctx.font = "12px Arial";

                drawPlayer(ctx, players, 1, avatarX_left, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 2, avatarX_center_left, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 3, avatarX_center, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 4, avatarX_center_right, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 5, avatarX_right, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 6, avatarX_center_right, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 7, avatarX_center, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 8, avatarX_center_left, avatarY_bottom, avatarRadius);
            }

            var drawUserCard = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                ctx.fillText(rank, x + 8, y + 25);
                var source = suitSpriteLocations[suit];
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + 12, y + 28, width * 0.7, height * 0.5);
                var rightOffsetX = rank.length > 1 ? 27 : 22;
                ctx.fillText(rank, x + width - rightOffsetX, y + height - 10);
            }

            var drawUserHand = function(ctx, canvas, rank1, suit1, rank2, suit2) {
                var x = canvas.width * 0.05;
                var y = canvas.height * 0.6;
                var width = canvas.width * 0.2;
                var height = canvas.width * 0.3; 

                var user = game.players[currentPlayerIndex];
                if (user.card1) {
                    drawUserCard(ctx, user.card1.rank, user.card1.suit, x, y, width, height);
                }
                if (user.card2) {
                    drawUserCard(ctx, user.card2.rank, user.card2.suit, x + width - 15, y, width, height);
                }
            };

            var areBlindsSet = function() {
                return (game.bigBlindIndex || game.bigBlindIndex === 0) && (game.littleBlindIndex || game.littleBlindIndex === 0);
            }

            var drawBlinds = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var blindLocations = [
                    { x: tableX + 10, y: tableY + (tableHeight / 2) },
                    { x: tableX + (tableWidth / 3) - (tableWidth / 6), y: tableY + 10 },
                    { x: tableX + (2 * tableWidth / 3) - (tableWidth / 6), y: tableY + 10 },
                    { x: tableX + (5 * tableWidth / 6), y: tableY + 10 },
                    { x: tableX + tableWidth - 15, y: tableY + (tableHeight / 2) + 2 },
                    { x: tableX + (5 * tableWidth / 6), y: tableY + tableHeight - 10 },
                    { x: tableX + (2 * tableWidth / 3) - (tableWidth / 6), y: tableY + tableHeight - 10 },
                    { x: tableX + (tableWidth / 3) - (tableWidth / 6), y: tableY + tableHeight - 10 }
                ];

                circle(ctx, blindLocations[game.bigBlindIndex].x, blindLocations[game.bigBlindIndex].y, 5, 'red', 'red', 1);
                circle(ctx, blindLocations[game.bigBlindIndex].x + 10, blindLocations[game.bigBlindIndex].y, 5, 'red', 'red', 1);
                circle(ctx, blindLocations[game.littleBlindIndex].x, blindLocations[game.littleBlindIndex].y, 5, 'red', 'red', 1);
            }

            var drawPlayerHands = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var index = 0;
                ctx.fillStyle = 'grey';

                game.players.forEach(player => {
                    var playerDeckLocation = getPlayerDeckLocation(index, tableX, tableY, tableWidth, tableHeight);
                    if (player.card1) {
                        ctx.fillRect(playerDeckLocation.x - 6, playerDeckLocation.y, 5, 8);
                    }
                    if (player.card2) {
                        ctx.fillRect(playerDeckLocation.x + 1, playerDeckLocation.y, 5, 8);
                    }

                    index++;
                });

                ctx.fillStyle = 'black';
            }

            var drawCardOnTable = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                ctx.font = '18px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                ctx.fillText(rank, x + 5, y + 15);
                var source = suitSpriteLocations[suit];
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + 8, y + 17, width * 0.7, height * 0.5);
            }

            var drawCardsOnTable = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                if (game.cardsOnTable.length > 0) {
                    ctx.lineWidth = 2;
                    var x = parseInt(tableX + (0.16 * tableWidth));
                    var y = parseInt(tableY + (0.28 * tableHeight));
                    var width = parseInt(tableWidth * 0.12);
                    var height = parseInt(width * 1.33);

                    game.cardsOnTable.forEach(card => {
                        drawCardOnTable(ctx, card.rank, card.suit, x, y, width, height);
                        x += tableWidth * 0.14;
                    });
                }
            }

            var drawPot = function(ctx, potAmount, tableX, tableY, tableWidth, tableHeight) {
                var offsetPerDigit = 2;
                var numberOfDigits = potAmount.toString().length;
                var x = tableX + (0.4 * tableWidth) - (offsetPerDigit * numberOfDigits);
                var y = tableY + (0.65 * tableHeight);

                ctx.font = '16px Arial';
                ctx.fillStyle = 'white';
                ctx.fillText('pot: ' + potAmount, x, y);
            }

            var drawRevealedHandsOnTable = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var index = 0;

                game.players.forEach(player => {
                    if (player.isShowingHand && player.card1) {
                        var playerDeckLocation = getPlayerDeckLocation(index, tableX, tableY, tableWidth, tableHeight);
                        ctx.lineWidth = 1;
                        var width = parseInt(tableWidth * 0.08);
                        var height = parseInt(width * 1.33);
                        drawRevealedCard(ctx, player.card1.suit, player.card1.rank, playerDeckLocation.x - width - 1, playerDeckLocation.y, width, height);
                        drawRevealedCard(ctx, player.card2.suit, player.card2.rank, playerDeckLocation.x + 1, playerDeckLocation.y, width, height);
                    }

                    index++;
                });
            }
            var drawRevealedCard = function(ctx, suit, rank, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y - 5, width, height, 5, true, false);
                roundRect(ctx, x, y - 5, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                ctx.font = '16px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                ctx.fillText(rank, x + 5, y + 10);
                var source = suitSpriteLocations[suit];
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + 7, y + 10, width * 0.6, height * 0.4);
            }
        </script>

        

       <script>

            var hideButtons = function() {
                document.getElementById('button-call-check').style.display = 'none';
                document.getElementById('button-raise-bet').style.display = 'none';
                document.getElementById('button-fold').style.display = 'none';
            }
            
            var showCallCheckButton = function() {
                var buttonText = isCheck() ? 'Check' : 'Call ' + (game.currentBet - game.players[currentPlayerIndex].currentBet);
                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showRaiseBetButton = function() {
                var buttonText = isBet() ? 'Bet' : 'Raise';
                var callCheckButton = document.getElementById('button-raise-bet');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showFoldButton = function() {
                document.getElementById('button-fold').style.display = 'inherit';
            }

            var showBetAmountDialog = function() {
                document.getElementById('bet-button').innerHTML = isBet() ? 'Bet' : 'Raise';
                document.getElementById('modal-overlay').style.display = 'block';
                document.getElementById('bet-amount-dialog').style.display = 'block';
            }

            var clearBetAmount = function() {
                document.getElementById('bet-amount').value = '';
            }

            var hideBetAmountDialog = function() {
                clearBetAmount();
                document.getElementById('modal-overlay').style.display = 'none';
                document.getElementById('bet-amount-dialog').style.display = 'none';
            }

            var onUserPlaceBet = function() {
                var betAmount = parseInt(document.getElementById('bet-amount').value) || 0;
                if (betAmount) {
                    clearBetAmount();
                    hideBetAmountDialog();
                    var actionType = isBet() ? 'bet' : 'raise';
                    
                   
                    // todo: fire event to server
                }
            }

            // if turn option is betting vs raising
            var isBet = function() {
                return game.currentBet === 0;
            }

            // if turn option is checking vs calling
            var isCheck = function() {
                return game.currentBet === 0 || (game.currentBet === game.bigBlindAmount && game.bigBlindIndex === currentPlayerIndex);
            }

            var setUserActions = function() {
                document.getElementById('button-call-check').onclick = function() {
                    var actionType = isCheck() ? 'check' : 'call';
                    onNextUserAction(actionType); 
                    // todo: fire event to server
                }

                document.getElementById('button-raise-bet').onclick = function() {
                    showBetAmountDialog();
                }

                document.getElementById('button-fold').onclick = function() {
                    onNextUserAction('fold');
                    // todo: fire event to server
                }

                document.getElementById('button-show-cards').onclick = function() {
                    players[currentPlayerIndex].isShowingHand = true;
                    hideLostHandButtons();
                    // todo: fire event to server that user has shown cards
                }

                document.getElementById('button-muck').onclick = function() {
                    hideLostHandButtons();
                    // todo: fire event to server that user has mucked
                }
            }

            var showLostHandButtons = function() {
                document.getElementById('button-show-cards').style.display = 'block';
                document.getElementById('button-muck').style.display = 'block';
            }

            var hideLostHandButtons = function() {
                document.getElementById('button-show-cards').style.display = 'none';
                document.getElementById('button-muck').style.display = 'none';
            }

         </script>

        <!-- Base logic function (draw, update) -->
        <script>
            var draw = function(canvas) {
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                var tableX = parseInt(canvas.width * 0.15);
                var tableY = parseInt(canvas.height * 0.15);
                var tableWidth = parseInt(canvas.width * 0.65);
                var tableHeight = parseInt(canvas.height * 0.25);

                drawTable(ctx, tableX, tableY, tableWidth, tableHeight);
                drawPlayers(ctx, game.players, tableX, tableY, tableWidth, tableHeight);

                if (currentPlayerIndex === 0 || currentPlayerIndex) {
                    drawUserHand(ctx, canvas);
                }

                if (areBlindsSet()) {
                    drawBlinds(ctx, tableX, tableY, tableWidth, tableHeight);
                }
                drawPlayerHands(ctx, tableX, tableY, tableWidth, tableHeight);

                drawCardsOnTable(ctx, tableX, tableY, tableWidth, tableHeight);
                var potAmount = game.currentPotAmount || 0;
                drawPot(ctx, potAmount, tableX, tableY, tableWidth, tableHeight);

                drawRevealedHandsOnTable(ctx, tableX, tableY, tableWidth, tableHeight);
            }
        </script>

        <!-- turn-taking transition, e.g. deal, flop -->
        <script>
            var handleDealTransition = function(updatedGame, activePlayersCount) {
                setMessageText('Dealing...');
                game.cardsOnTable = [];
                game.players.forEach(player => {
                    player.card1 = null;
                    player.card2 = null;
                    player.isShowingHand = false;
                });

                var cardTimeout = 0;
                var cardDealInterval = 200;
                var roundOfCardsTime = (activePlayersCount - 1) * cardDealInterval;

                var numberOfCardsDealt = 0;
                var totalCardsNeeded = activePlayersCount * 2;
                for (var i = updatedGame.currentTurnIndex; i < updatedGame.currentTurnIndex + updatedGame.players.length; i++) {
                    var currentIndex = i >= updatedGame.players.length ? i - updatedGame.players.length : i;
                    if (!updatedGame.players[currentIndex].isOut) {
                        setTimeout(function(index) {
                            game.players[index].card1 = updatedGame.players[index].card1;
                            numberOfCardsDealt++;
                        }, cardTimeout, currentIndex);
                        setTimeout(function(index) {
                            game.players[index].card2 = updatedGame.players[index].card2;
                            numberOfCardsDealt++;
                            if (numberOfCardsDealt === totalCardsNeeded) {
                                setMessageText('Player "' + updatedGame.players[updatedGame.currentTurnIndex].name + '"\'s turn.');
                                game = updatedGame;
                            }
                        }, cardTimeout + roundOfCardsTime, currentIndex);
                        cardTimeout += cardDealInterval;
                    }
                }
            }

            var handleFlopTransition = function(updatedGame) {
                var timeout = 0;
                for (var i = 0; i < 3; i++) {
                    setTimeout((index) => {
                        if (index === 2) {
                            game = updatedGame;
                        }
                        else {
                            game.cardsOnTable.push(updatedGame.cardsOnTable[index]);
                        }
                    }, timeout, i);
                    timeout += 300;
                }
            }
        </script>

        <!-- communication w/ server -->
        <script>
            var beginListenForMessages = function() {
                gameSocket.onmessage = function(event) {
                    console.log("MESSAGE RECEIVED: ", event.data);
                    var message = JSON.parse(event.data);
                    var isGameSetInstantly = true;

                    if (message.action) {
                        switch (message.action) {
                            case 'deal':
                                isGameSetInstantly = false;
                                handleDealTransition(message.game, message.activePlayersCount);
                                break;
                            case 'flop': 
                                isGameSetInstantly = false;
                                handleFlopTransition(message.game);
                                break;
                            case 'playerAdded':
                                if (message.playerName !== currentPlayer.name) {
                                    var matchingPlayers = game.players.filter(player => {
                                        return player.name === message.playerName;
                                    });
                                    if (matchingPlayers.length > 0) {
                                        matchingPlayers[0].numberOfChips += message.numberOfChips;
                                    }
                                }
                        }
                    }

                    if (message.game) {
                        if (currentPlayerIndex === null) {
                            for (var i = 0; i < message.game.players.length && currentPlayerIndex === null; i++) {
                                if (message.game.players[i].name === currentPlayer.name) {
                                    currentPlayerIndex = i;
                                }
                            }
                        }

                        if (isGameSetInstantly) {
                            game = message.game;
                        }
                    }

                    if (message.message) {
                        setMessageText(message.message);
                    }
                };
            }

            var addChips = function(numberOfChips) {
                currentPlayer.numberOfChips += numberOfChips;
                var addChipsRequest = {
                    gameId: game.id,
                    playerName: currentPlayer.name,
                    numberOfChips: numberOfChips
                };
                gameSocket.send(JSON.stringify(addChipsRequest));
            }
        </script>

        <script>
            var game = null;
            var currentPlayer = null;
            var currentPlayerIndex = null;
            var gameSocket = null;

            window.onload = function() {
                gameSocket = new WebSocket('ws://poker-giver.herokuapp.com/');

                // /// GAME READY/INIT
               document.addEventListener("message", function(event) {
                    var messageData =  {player: {
                        id: 'b3c1b8a9-9fdd-4a82-a12a-750542629b77',
                        name: 'Nick Redmond'
                    },
                    gameId: '73bf5cc7-70e3-4ed2-8766-8a2e47e6fc2a'}//JSON.parse(event.data);
                    currentPlayer = messageData.player;
                   // gameSocket.onopen = function() {
                        var gameJoinRequest = {
                            action: 'joinGame',
                            gameId: messageData.gameId,
                            playerId: currentPlayer.id
                        }
                        gameSocket.send(JSON.stringify(gameJoinRequest));
                   // }
                    beginListenForMessages();
               });

                // begin: test

                // var messageData = {
                //     player: {
                //         id: 'b3c1b8a9-9fdd-4a82-a12a-750542629b77',
                //         name: 'Nick Redmond'
                //     },
                //     gameId: '73bf5cc7-70e3-4ed2-8766-8a2e47e6fc2a'
                // }
                //     currentPlayer = messageData.player;
                    
                //     gameSocket.onopen = function() {
                //         var gameJoinRequest = {
                //             action: 'joinGame',
                //             gameId: messageData.gameId,
                //             playerId: currentPlayer.id
                //         }
                //         gameSocket.send(JSON.stringify(gameJoinRequest));
                //     }
                //     beginListenForMessages();

                // end: test

                setUserActions();

                var canvas = document.getElementById('tableCanvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                var canvasRect = canvas.getBoundingClientRect();

                loadSpritesConfig();
                loadButtons(canvasRect.left, canvasRect.top, canvas.width, canvas.height);
                loadDialogs(canvasRect.left, canvasRect.top, canvas.width, canvas.height);

                setInterval(function() {
                    if (game && currentPlayer) {
                        draw(canvas);
                    }
                }, 1000 / 24);

                // begin test
                setMessageText("test test test");
            }
        </script>

        
    </body>
</html>