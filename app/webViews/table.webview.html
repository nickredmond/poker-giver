<html>
    <head></head>
    <body style="background-color: #dedede">
        <div id="message-box"></div>
        <div style="text-align: center">
            <button id="button-call-check" class="game-button">none</button>
            <button id="button-raise-bet" class="game-button">none</button>
            <button id="button-fold" class="game-button">Fold</button>
        </div>
        <div id="modal-overlay"></div>
        <div id="bet-amount-dialog">
            <p>Enter amount:</p>
            <input id="bet-amount" type="number" />
            <div id="bet-button-holder">
                <button id="cancel-button" class="bet-dialog-button" onclick="hideBetAmountDialog()">Cancel</button>
                <button id="bet-button" class="bet-dialog-button" onclick="onUserPlaceBet()">none</button>
            </div>
        </div>
        <canvas id="tableCanvas" width="100%" height="100%"></canvas>
        <style>
            .game-button {
                position: absolute;
                z-index: 998;
                padding: 0.35em 1em;
                font-size: 1.25em;
                display: none;
                width: 7em;
                color: white;
                font-weight: bold;
                border: none;
            }

            #modal-overlay {
                position: absolute;
                z-index: 999;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: none;
            }

            #bet-amount-dialog {
                position: absolute;
                z-index: 1000;
                padding: 0 1em 1em 1em;
                display: none;
                background-color: #444;
                text-align: center;
            }
            #bet-amount-dialog p {
                color: white;
                font-size: 1.15em;
                margin-bottom: 0.25em;
            }
            #bet-button-holder {
                text-align: center;
            }
            .bet-dialog-button {
                border: none;
                color: white;
                margin-top: 0.5em;
                font-weight: bold;
                font-size: 1.3em;
                padding: 0.25em;
            }
            #bet-button {
                background-color: #117711;
                margin-left: 0.5em;
            }
            #cancel-button {
                background-color: #991111;
            }

            #button-call-check {
                background-color: #0808FF;
            }
            #button-raise-bet {
                background-color: #117711;
            }
            #button-fold {
                background-color: #991111;
            }

            #bet-amount {
                font-size: 1.2em;
            }

            #message-box {
                text-align: center;
                margin-bottom: 1em;
                padding: 0.25em 0;
                border: 1px solid #888;
                min-height: 1em;
                font-size: 1.25em;
            }
        </style>

        <!-- Utility drawing functions, e.g. rounded rect, circle, etc -->
        <script>
            var setMessageText = function(text) {
                document.getElementById('message-box').innerHTML = text;
            }

            /** https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas */
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke == 'undefined') {
                    stroke = true;
                }
                if (typeof radius === 'undefined') {
                    radius = 5;
                }
                if (typeof radius === 'number') {
                    radius = {tl: radius, tr: radius, br: radius, bl: radius};
                } else {
                    var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
                    for (var side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                    }
                }
                ctx.beginPath();
                ctx.moveTo(x + radius.tl, y);
                ctx.lineTo(x + width - radius.tr, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                ctx.lineTo(x + width, y + height - radius.br);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                ctx.lineTo(x + radius.bl, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                ctx.lineTo(x, y + radius.tl);
                ctx.quadraticCurveTo(x, y, x + radius.tl, y);
                ctx.closePath();
                if (fill) {
                    ctx.fill();
                }
                if (stroke) {
                    ctx.stroke();
                }

            }

            function circle(ctx, centerX, centerY, radius, fillStyle, strokeStyle, lineWidth) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = fillStyle;
                ctx.fill();
                ctx.lineWidth = lineWidth || 3;
                ctx.strokeStyle = strokeStyle;
                ctx.stroke();
            }
        </script>

        <!-- Handle data from React Native -->
        <script>
            var handleMessageFromApp = function(event) {
                // var messageData = JSON.parse(event.data);
                // alert("name: " + messageData.name);
                alert("hmmmm ")
            };
        </script>

        <!-- Constants -->
        <script>
            var DECK_OF_CARDS = [
                { rank: 'A', suit: 'spade' }, { rank: 'A', suit: 'diamond' }, { rank: 'A', suit: 'club' }, { rank: 'A', suit: 'heart' },
                { rank: '2', suit: 'spade' }, { rank: '2', suit: 'diamond' }, { rank: '2', suit: 'club' }, { rank: '2', suit: 'heart' },
                { rank: '3', suit: 'spade' }, { rank: '3', suit: 'diamond' }, { rank: '3', suit: 'club' }, { rank: '3', suit: 'heart' },
                { rank: '4', suit: 'spade' }, { rank: '4', suit: 'diamond' }, { rank: '4', suit: 'club' }, { rank: '4', suit: 'heart' },
                { rank: '5', suit: 'spade' }, { rank: '5', suit: 'diamond' }, { rank: '5', suit: 'club' }, { rank: '5', suit: 'heart' },
                { rank: '6', suit: 'spade' }, { rank: '6', suit: 'diamond' }, { rank: '6', suit: 'club' }, { rank: '6', suit: 'heart' },
                { rank: '7', suit: 'spade' }, { rank: '7', suit: 'diamond' }, { rank: '7', suit: 'club' }, { rank: '7', suit: 'heart' },
                { rank: '8', suit: 'spade' }, { rank: '8', suit: 'diamond' }, { rank: '8', suit: 'club' }, { rank: '8', suit: 'heart' },
                { rank: '9', suit: 'spade' }, { rank: '9', suit: 'diamond' }, { rank: '9', suit: 'club' }, { rank: '9', suit: 'heart' },
                { rank: '10', suit: 'spade' }, { rank: '10', suit: 'diamond' }, { rank: '10', suit: 'club' }, { rank: '10', suit: 'heart' },
                { rank: 'J', suit: 'spade' }, { rank: 'J', suit: 'diamond' }, { rank: 'J', suit: 'club' }, { rank: 'J', suit: 'heart' },
                { rank: 'Q', suit: 'spade' }, { rank: 'Q', suit: 'diamond' }, { rank: 'Q', suit: 'club' }, { rank: 'Q', suit: 'heart' },
                { rank: 'K', suit: 'spade' }, { rank: 'K', suit: 'diamond' }, { rank: 'K', suit: 'club' }, { rank: 'K', suit: 'heart' },
            ];
        </script>

        <!-- Get data for game -->
        <script>
            var getPlayers = function() {
                // sent from react native
                return players || [];
            };

            var getAvatarColor = function(playerNumber) {
                var colors = [
                    'purple',
                    'yellow',
                    'blue',
                    'orange',
                    'green',
                    'red',
                    'brown',
                    'pink'
                ];
                return colors[playerNumber - 1];
            }

            var getPlayerDeckLocation = function(playerIndex, tableX, tableY, tableWidth, tableHeight) {
                var deckLocation = {};

                switch (playerIndex) {
                    case 0: 
                        deckLocation = {
                            x: tableX + 20,
                            y: tableY + (tableHeight * 0.5) + 10
                        };
                        break;
                    case 1: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.25),
                            y: tableY + 20
                        };
                        break;
                    case 2: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.5),
                            y: tableY + 20
                        };
                        break;
                    case 3: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.75),
                            y: tableY + 20
                        };
                        break;
                    case 4: 
                        deckLocation = {
                            x: tableX + tableWidth - 20,
                            y: tableY + (tableHeight * 0.5) - 15
                        };
                        break;
                    case 5: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.75),
                            y: tableY + tableHeight - 28
                        };
                        break;
                    case 6: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.5),
                            y: tableY + tableHeight - 28
                        };
                        break;
                    case 7: 
                        deckLocation = {
                            x: tableX + (tableWidth * 0.25),
                            y: tableY + tableHeight - 28
                        };
                        break;
                }

                return deckLocation;
            }
        </script>

        <!-- Config data, e.g. sprite image locations -->
        <script>
            var cardsSprite;
            var spritesLocations;
            var spriteWidth;
            var spriteHeight;

            var suitsSprite;

            var loadButtons = function(canvasX, canvasY, canvasWidth, canvasHeight) {
                var buttonsLeft = canvasX + parseInt(canvasWidth * 0.5);

                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.style.top = canvasY + parseInt(canvasHeight * 0.6);
                callCheckButton.style.left = buttonsLeft;

                var raiseBetButton = document.getElementById('button-raise-bet');
                raiseBetButton.style.top = canvasY + parseInt(canvasHeight * 0.7);
                raiseBetButton.style.left = buttonsLeft;

                var foldButton = document.getElementById('button-fold');
                foldButton.style.top = canvasY + parseInt(canvasHeight * 0.8);
                foldButton.style.left = buttonsLeft;
            }

            var loadDialogs = function(canvasX, canvasY, canvasWidth, canvasHeight) {
                var betDialogLeft = canvasX + parseInt(canvasWidth * 0.05);
                var betDialogTop = canvasY + parseInt(canvasHeight * 0.25);
                var betDialog = document.getElementById('bet-amount-dialog');
                betDialog.style.left = betDialogLeft;
                betDialog.style.top = betDialogTop;
                betDialog.style.width = parseInt(canvasWidth * 0.75);
            }

            var loadSpritesConfig = function() {
                cardsSprite = new Image();
                cardsSprite.src = 'https://i.ibb.co/ZB85jHT/card-deck-161536-1280.png';

                suitsSprite = new Image();
                suitsSprite.src = 'https://i.ibb.co/R4X28Nd/suits.png';
                
                var numberOfColumns = 13;
                var numberOfRows = 5;
                var widthPerColumn = spriteWidth = cardsSprite.width / numberOfColumns;
                var heightPerColumn = spriteHeight =  cardsSprite.height / numberOfRows;

                spritesLocations = {};
                var ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                var suits = ['Clubs', 'Diamonds', 'Hearts', 'Spades'];
                for (var rank = 0; rank < ranks.length; rank++) {
                    for (var suit = 0; suit < suits.length; suit++) {
                        var x = rank * widthPerColumn;
                        var y = suit * heightPerColumn;
                        var rankName = ranks[rank];
                        var suitName = suits[suit];
                        
                        if (suit === 0) {
                            spritesLocations[rankName] = {};
                        }
                        spritesLocations[rankName][suitName] = { x, y };
                    }
                }
            }

            var userOutlineInterval;
            var animateUserOutline = function() {
                userOutlineInterval = setInterval(() => {
                    userOutlineColor = (userOutlineColor === 'white') ? 'black' : 'white';
                }, 750);
            }
            var stopUserOutlineAnimation = function() {
                if (userOutlineInterval) {
                    clearInterval(userOutlineInterval);
                    userOutlineColor = 'black';
                    userOutlineInterval = null;
                }
            }

            var suitSpriteLocations = {
                'spade': {
                    getX: function() { return 0; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'heart': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return 0; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'diamond': {
                    getX: function() { return 0; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                },
                'club': {
                    getX: function() { return suitsSprite.width * 0.64; },
                    getY: function() { return suitsSprite.height * 0.6; },
                    getWidth: function() { return suitsSprite.width * 0.36; },
                    getHeight: function() { return suitsSprite.height * 0.4; }
                }
            }
        </script>

        <!-- Load data from external source -->
        <script>
            
            
        </script>

        <!-- Draw functions -->
        <script>
            var drawTable = function(ctx, x, y, width, height) {
                var radius = 50;
                ctx.fillStyle = "#046908";
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 5;
                roundRect(ctx, x, y, width, height, radius, true);
            }

            var drawPlayerInfo = function(ctx, text, x, y, yOffset) {
                var xOffset = 5 - parseInt(text.length * 3.5);
                var finalX = x + xOffset
                var finalY = y + yOffset
                ctx.fillStyle = 'black';
                ctx.fillText(text, finalX, finalY);
            }

            var userOutlineColor = 'black'; // interval exists to alternate colors
            var drawPlayer = function(ctx, players, playerNumber, x, y, radius) {
                var color = players && players.length >= playerNumber ? getAvatarColor(playerNumber) : 'grey';
                var outlineColor = 'black';
                var playerIndex = playerNumber - 1;
                if (playerIndex === currentPlayerIndex) {
                    outlineColor = userOutlineColor;
                }
                else if (playerIndex === currentTurnIndex) {
                    outlineColor = 'white';
                }
                circle(ctx, x, y, radius, color, outlineColor);

                var isPlayerInSeat = players && players.length >= playerNumber;
                var playerName = isPlayerInSeat ? players[playerNumber - 1].name : '[Empty]';
                drawPlayerInfo(ctx, playerName, x, y + radius, 12);
                if (isPlayerInSeat) {
                    var playerWorth = players[playerNumber - 1].numberOfChips || 0;
                    drawPlayerInfo(ctx, playerWorth.toString(), x - 5, y + radius, 25);
                }
            }

            var drawPlayers = function(ctx, players, tableX, tableY, tableWidth, tableHeight) {
                var avatarRadius = parseInt(tableWidth / 11);

                var avatarX_left = parseInt(tableX * 0.5);
                var avatarX_center_left = parseInt(tableX + (0.2 * tableWidth));
                var avatarX_center = parseInt(tableX + (0.5 * tableWidth));
                var avatarX_center_right = parseInt(tableX + (0.8 * tableWidth));
                var avatarX_right = parseInt(tableX + (tableWidth * 1.15));

                var avatarY_top = parseInt(tableY * 0.33);
                var avatarY_center = parseInt(tableY + (0.5 * tableHeight));
                var avatarY_bottom = parseInt(tableY + tableHeight + (0.4 * tableY));

                ctx.font = "12px Arial";

                drawPlayer(ctx, players, 1, avatarX_left, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 2, avatarX_center_left, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 3, avatarX_center, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 4, avatarX_center_right, avatarY_top, avatarRadius);
                drawPlayer(ctx, players, 5, avatarX_right, avatarY_center, avatarRadius);
                drawPlayer(ctx, players, 6, avatarX_center_right, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 7, avatarX_center, avatarY_bottom, avatarRadius);
                drawPlayer(ctx, players, 8, avatarX_center_left, avatarY_bottom, avatarRadius);

                playerName = players && players.length >= 2
            }

            var drawUserCard = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                ctx.fillText(rank, x + 8, y + 25);
                var source = suitSpriteLocations[suit];
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + 12, y + 28, width * 0.7, height * 0.5);
                var rightOffsetX = rank.length > 1 ? 27 : 22;
                ctx.fillText(rank, x + width - rightOffsetX, y + height - 10);
            }

            var drawUserHand = function(ctx, canvas, rank1, suit1, rank2, suit2) {
                var x = canvas.width * 0.05;
                var y = canvas.height * 0.6;
                var width = canvas.width * 0.2;
                var height = canvas.width * 0.3; 

                var user = players[currentPlayerIndex];
                if (user.card1) {
                    drawUserCard(ctx, user.card1.rank, user.card1.suit, x, y, width, height);
                }
                if (user.card2) {
                    drawUserCard(ctx, user.card2.rank, user.card2.suit, x + width - 15, y, width, height);
                }
            };

            var drawBlinds = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var blindLocations = [
                    { x: tableX + 10, y: tableY + (tableHeight / 2) },
                    { x: tableX + (tableWidth / 3) - (tableWidth / 6), y: tableY + 10 },
                    { x: tableX + (2 * tableWidth / 3) - (tableWidth / 6), y: tableY + 10 },
                    { x: tableX + (5 * tableWidth / 6), y: tableY + 10 },
                    { x: tableX + tableWidth - 15, y: tableY + (tableHeight / 2) + 2 },
                    { x: tableX + (5 * tableWidth / 6), y: tableY + tableHeight - 10 },
                    { x: tableX + (2 * tableWidth / 3) - (tableWidth / 6), y: tableY + tableHeight - 10 },
                    { x: tableX + (tableWidth / 3) - (tableWidth / 6), y: tableY + tableHeight - 10 }
                ];

                circle(ctx, blindLocations[bigBlindIndex].x, blindLocations[bigBlindIndex].y, 5, 'red', 'red', 1);
                circle(ctx, blindLocations[bigBlindIndex].x + 10, blindLocations[bigBlindIndex].y, 5, 'red', 'red', 1);
                circle(ctx, blindLocations[littleBlindIndex].x, blindLocations[littleBlindIndex].y, 5, 'red', 'red', 1);
            }

            var drawPlayerHands = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                var index = 0;
                ctx.fillStyle = 'grey';

                players.forEach(player => {
                    var playerDeckLocation = getPlayerDeckLocation(index, tableX, tableY, tableWidth, tableHeight);
                    if (player.card1) {
                        ctx.fillRect(playerDeckLocation.x - 6, playerDeckLocation.y, 5, 8);
                    }
                    if (player.card2) {
                        ctx.fillRect(playerDeckLocation.x + 1, playerDeckLocation.y, 5, 8);
                    }

                    index++;
                });

                ctx.fillStyle = 'black';
            }

            var drawCardOnTable = function(ctx, rank, suit, x, y, width, height) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';

                roundRect(ctx, x, y, width, height, 5, true, false);
                roundRect(ctx, x, y, width, height, 5, false, true);

                ctx.fillStyle = 'black';
                ctx.font = '18px Arial';

                if (rank.length > 1) {
                    x -= 5;
                }

                ctx.fillText(rank, x + 5, y + 15);
                var source = suitSpriteLocations[suit];
                ctx.drawImage(suitsSprite, source.getX(), source.getY(), source.getWidth(), source.getHeight(), x + 8, y + 17, width * 0.7, height * 0.5);
            }

            var drawCardsOnTable = function(ctx, tableX, tableY, tableWidth, tableHeight) {
                if (cardsOnTable.length > 0) {
                    ctx.lineWidth = 2;
                    var x = parseInt(tableX + (0.16 * tableWidth));
                    var y = parseInt(tableY + (0.28 * tableHeight));
                    var width = parseInt(tableWidth * 0.12);
                    var height = parseInt(width * 1.33);

                    cardsOnTable.forEach(card => {
                        drawCardOnTable(ctx, card.rank, card.suit, x, y, width, height);
                        x += tableWidth * 0.14;
                    });
                }
            }

            var drawPot = function(ctx, potAmount, tableX, tableY, tableWidth, tableHeight) {
                var offsetPerDigit = 2;
                var numberOfDigits = potAmount.toString().length;
                var x = tableX + (0.4 * tableWidth) - (offsetPerDigit * numberOfDigits);
                var y = tableY + (0.65 * tableHeight);

                ctx.font = '16px Arial';
                ctx.fillStyle = 'white';
                ctx.fillText('pot: ' + potAmount, x, y);
            }
        </script>

        <!-- AI logic functions -->
        <script>
            var beginAiTurn = function() {
                var turnLengthMillis = (Math.random() * 2500) + 300;
                setTimeout(() => {
                    try {
                        var player = players[currentTurnIndex];
                        var cards = cardsOnTable.concat([player.card1, player.card2]);

                        var maxBetAmount = 1000;
                        var oddsOfBetting = 1;
                        var oddsOfFolding = 0;
                        var isHandFound = false;

                        var handTiers = [
                            [getRoyalFlush, getStraightFlush, getFourofaKind],
                            [getFullHouse, getFlush, getStraight],
                            [getThreeofaKind, getTwoPair, getPair],
                        ];

                        for (var i = 0; i < handTiers.length && !isHandFound; i++) {
                            var handChecks = handTiers[i];
                            for (var j = 0; j < handTiers[i].length && !isHandFound; j++) {
                                isHandFound = handChecks[j](cards) !== null;

                                if (!isHandFound) {
                                    maxBetAmount -= 55;
                                    oddsOfBetting -= 0.01;
                                    oddsOfFolding += 0.01;
                                }
                            }
                            if (!isHandFound) {
                                maxBetAmount -= 105;
                                oddsOfBetting -= 0.22;
                                oddsOfFolding += 0.08;
                            }
                        }

                        if (cardsOnTable.length > 3) {
                            maxBetAmount -= 75 * (cardsOnTable - 3);
                            oddsOfBetting -= 0.08 * (cardsOnTable - 3);
                            oddsOfFolding += (maxBetAmount > 500) ? 0 : 0.05;
                        }

                        var isFold = false;
                        if (player.currentBet < currentBet) {
                            isFold = oddsOfFolding > Math.random();
                        }

                        if (isFold) {
                            onNextUserAction('fold');
                        }
                        else {
                            var isAggressive = oddsOfBetting > Math.random();
                            if (isAggressive) {
                                var betAmount = Math.random() * maxBetAmount;
                                var action = (currentBet === 0) ? 'bet' : 'raise';
                                onNextUserAction(action, betAmount);
                            }
                            else {
                                var action = (currentBet === 0) ? 'check' : 'call';
                                onNextUserAction(action);
                            }
                        }
                    } catch (error) {
                        // todo: handle this more gracefully... or just remove w/ removal of AI?
                        setMessageText("error (deal).");
                        alert("error: [ name:" + error.name + ", message:" + error.message + ", stack: " + error.stack + " ]");
                    }
                }, turnLengthMillis);
            }
        </script>

        <!-- Logic functions -->
        <script>
            var currentDeck;
            var shuffleCards = function() {
                var unshuffledCards = JSON.parse(JSON.stringify(DECK_OF_CARDS));
                var shuffledCards = [];

                for (var i = 0; i < DECK_OF_CARDS.length; i++) {
                    var nextCardIndex = Math.floor(Math.random() * unshuffledCards.length);
                    shuffledCards.push(unshuffledCards[nextCardIndex]);
                    unshuffledCards.splice(nextCardIndex, 1);
                }

                return shuffledCards;
            }

            var bigBlindIndex;
            var littleBlindIndex;
            var bigBlindAmount;
            var littleBlindAmount;

            var incrementBlinds = function() {
                if (!bigBlindIndex && bigBlindIndex !== 0) {
                    bigBlindIndex = Math.floor(Math.random() * players.length);
                    littleBlindIndex = bigBlindIndex === 0 ? players.length - 1 : bigBlindIndex - 1;
                }
                else {
                    do {
                        bigBlindIndex++;
                        if (bigBlindIndex >= players.length) {
                            bigBlindIndex = 0;
                        }
                    } while(players[bigBlindIndex].isOut);
                    littleBlindIndex = bigBlindIndex === 0 ? players.length - 1 : bigBlindIndex - 1;

                    while (players[littleBlindIndex].isOut) {
                        littleBlindIndex--;
                        if (littleBlindIndex < 0) {
                            littleBlindIndex = players.length - 1;
                        }
                    }
                }
            }

            var deductBlindsFromPlayers = function() {
                players[bigBlindIndex].numberOfChips -= bigBlindAmount;
                players[bigBlindIndex].currentBet = bigBlindAmount;
                if (players[bigBlindIndex].numberOfChips < 0) {
                    players[bigBlindIndex].numberOfChips = 0;
                }

                players[littleBlindIndex].numberOfChips -= littleBlindAmount;
                players[littleBlindIndex].currentBet = littleBlindAmount;
                if (players[littleBlindIndex].numberOfChips < 0) {
                    players[littleBlindIndex].numberOfChips = 0;
                }
            }

            var areBlindsSet = function() {
                return (bigBlindIndex || bigBlindIndex === 0) && (littleBlindIndex || littleBlindIndex === 0);
            }

            var currentCardIndex = 0;
            var drawCardFromDeck = function() {
                var nextCard = currentDeck[currentCardIndex];
                currentCardIndex++;
                return nextCard;
            }

            var currentTurnIndex;
            var currentBet = 0;
            var currentPotAmount = 0;
            var beginDeal = function(onDealComplete) {
                try {
                    players.forEach(player => {
                        player.currentBet = 0;
                        player.isPlayed = false;
                        player.isOut = player.numberOfChips <= 0;
                    });

                    var activePlayersCount = getActivePlayersCount();
                    if (activePlayersCount < 2) {
                        // todo: impelement end-game for this scenario
                        alert("congrats! you beat everyone!");
                    }
                    
                    setMessageText('Dealing...');

                    incrementBlinds();
                    currentBet = bigBlindAmount;
                    currentPotAmount = bigBlindAmount + littleBlindAmount;
                    deductBlindsFromPlayers();

                    currentDeck = shuffleCards();
                    currentCardIndex = 0;
                    var cardTimeout = 0;
                    var cardDealInterval = 200;
                    var roundOfCardsTime = (players.length - 1) * cardDealInterval;

                    currentTurnIndex = bigBlindIndex;
                    var isBeforeDeal = true;
                    incrementTurnIndex(isBeforeDeal);

                    var numberOfCardsDealt = 0;
                    var totalCardsNeeded = activePlayersCount * 2;
                    for (var i = currentTurnIndex; i < currentTurnIndex + players.length; i++) {
                        var currentIndex = i >= players.length ? i - players.length : i;
                        var player = players[currentIndex];
                        player.card1 = null;
                        player.card2 = null;

                        if (!player.isOut) {
                            setTimeout(function(nextPlayer) {
                                var nextCard = drawCardFromDeck();
                                nextPlayer.card1 = nextCard;
                                numberOfCardsDealt++;
                            }, cardTimeout, player);

                            setTimeout(function(nextPlayer) {
                                var nextCard = drawCardFromDeck();
                                nextPlayer.card2 = nextCard;
                                numberOfCardsDealt++;

                                if (numberOfCardsDealt === totalCardsNeeded) {
                                    setMessageText('Player "' + players[currentTurnIndex].name + '"\'s turn.');
                                    onDealComplete();
                                }
                            }, cardTimeout + roundOfCardsTime, player);

                            cardTimeout += cardDealInterval;
                        }
                    }
                } catch (error) {
                    // todo: handle this more gracefully...
                    setMessageText("error (deal).");
                    alert("error: [ name:" + error.name + ", message:" + error.message + ", stack: " + error.stack + " ]");
                }
            }

            var hideButtons = function() {
                document.getElementById('button-call-check').style.display = 'none';
                document.getElementById('button-raise-bet').style.display = 'none';
                document.getElementById('button-fold').style.display = 'none';
            }
            
            var showCallCheckButton = function() {
                var buttonText = isCheck() ? 'Check' : 'Call ' + (currentBet - players[currentPlayerIndex].currentBet);
                var callCheckButton = document.getElementById('button-call-check');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showRaiseBetButton = function() {
                var buttonText = isBet() ? 'Bet' : 'Raise';
                var callCheckButton = document.getElementById('button-raise-bet');
                callCheckButton.innerHTML = buttonText;
                callCheckButton.style.display = 'inherit';
            }

            var showFoldButton = function() {
                document.getElementById('button-fold').style.display = 'inherit';
            }

            var showBetAmountDialog = function() {
                document.getElementById('bet-button').innerHTML = isBet() ? 'Bet' : 'Raise';
                document.getElementById('modal-overlay').style.display = 'block';
                document.getElementById('bet-amount-dialog').style.display = 'block';
            }

            var clearBetAmount = function() {
                document.getElementById('bet-amount').value = '';
            }

            var hideBetAmountDialog = function() {
                clearBetAmount();
                document.getElementById('modal-overlay').style.display = 'none';
                document.getElementById('bet-amount-dialog').style.display = 'none';
            }

            var onUserPlaceBet = function() {
                var betAmount = parseInt(document.getElementById('bet-amount').value) || 0;
                if (betAmount) {
                    clearBetAmount();
                    hideBetAmountDialog();
                    var actionType = isBet() ? 'bet' : 'raise';
                    onNextUserAction(actionType, betAmount);
                }
            }

            // if turn option is betting vs raising
            var isBet = function() {
                return currentBet === 0;
            }

            // if turn option is checking vs calling
            var isCheck = function() {
                return currentBet === 0 || (currentBet === bigBlindAmount && bigBlindIndex === currentPlayerIndex);
            }

            // returns hand containing rank (royal flush for this method) or null if no hand
            var getRoyalFlush = function(cards) {
                var straightFlush;
                var royalFlush = null;

                if (cards.length >= 5) {
                    straightFlush = getStraightFlush(cards);
                }
                if (straightFlush && straightFlush[0].rank === 'A') {
                    royalFlush = straightFlush;
                }

                return royalFlush;
            }
        
            var getStraightFlush = function(cards) {
                var isExtraCardsExcluded = false;
                var flush = getFlush(cards, isExtraCardsExcluded);
                var straightFlush = flush ? getStraight(flush) : null;

                return straightFlush;
            }

            var getFourofaKind = function(cards) {
                var cardsByRank = {};
                var fourOfaKind = null;
                
                for (var i = 0; i < cards.length && !fourOfaKind; i++) {
                    var card = cards[i];
                    if (cardsByRank[card.rank]) {
                        cardsByRank[card.rank].push(card);
                        if (cardsByRank[card.rank].length === 4) {
                            fourOfaKind = cardsByRank[card.rank];
                        }
                    }
                    else {
                        cardsByRank[card.rank] = [card];
                    }
                }
                
                var maxRankingCard = null;
                if (fourOfaKind) {
                    Object.keys(cardsByRank).forEach(rank => {
                        if (maxRankingCard === null && rank !== fourOfaKind[0].rank) {
                            maxRankingCard = cardsByRank[rank][0];
                        }
                        else {
                            var maxCardScore = maxRankingCard ? getCardScore(maxRankingCard.rank) : 0;
                            if (rank !== fourOfaKind[0].rank && getCardScore(rank, true) > maxCardScore) {
                                maxRankingCard = cardsByRank[rank][0];
                            }
                        }
                    });
                }
                
                var result = null;
                if (fourOfaKind) {
                    result = fourOfaKind.concat(maxRankingCard);
                }
                return result;
            }
            
            var getFullHouse = function(cards) {
                var twoOfSameRank = null;
                var threeOfSameRank = null;

                if (cards.length >= 5) {
                    var cardsByRank = {};
                    cards.forEach(card => {
                        if (cardsByRank[card.rank]) {
                            cardsByRank[card.rank].push(card);
                        }
                        else {
                            cardsByRank[card.rank] = [card];
                        }
                    });

                    var ranks = Object.keys(cardsByRank);
                    for (var i = 0; i < ranks.length; i++) {
                        if (cardsByRank[ranks[i]].length >= 3) {
                            threeOfSameRank = cardsByRank[ranks[i]];
                        }
                        else if (cardsByRank[ranks[i]].length >= 2) {
                            if (!twoOfSameRank || cardsByRank[ranks[i]][0].rank > twoOfSameRank[0].rank) {
                                twoOfSameRank = cardsByRank[ranks[i]];
                            }
                        }
                    }
                }
                
                var result = null;
                if (threeOfSameRank && twoOfSameRank) {
                    threeOfSameRank = threeOfSameRank.slice(0, 3);
                    twoOfSameRank = twoOfSameRank.slice(0, 2);
                    result = threeOfSameRank.concat(twoOfSameRank);
                }
                return result;
            }

            /** return flush or null if there is none
             * @param isExtraCardsExcluded (opt) - if true, only the highest five cards in the suit 
             *      will be returned. if false, all cards in the matching suit (5-7 cards) will be 
             *      returned.
             */
             getFlush = function(cards, isExtraCardsExcluded = true) {
                var isHand = cards.length >= 5;
                var cardsInSuit = null;

                if (isHand) {
                    var cardsBySuit = {};
                    cards.forEach(card => {
                        if (cardsBySuit[card.suit]) {
                            cardsBySuit[card.suit].push(card);
                        }
                        else {
                            cardsBySuit[card.suit] = [card];
                        }
                    });

                    var suits = Object.keys(cardsBySuit);
                    for (var i = 0; i < suits.length && !cardsInSuit; i++) {
                        if (cardsBySuit[suits[i]].length >= 5) {
                            cardsInSuit = cardsBySuit[suits[i]];
                            if (isExtraCardsExcluded) {
                                var isAceHigh = true;
                                var sortingFunction = generateCardSortingFunction(isAceHigh);
                                cardsInSuit.sort(sortingFunction);
                                cardsInSuit = cardsInSuit.slice(0, 5);
                            }
                        }
                    }
                }

                return cardsInSuit;
            }

            var getStraight = function(cards) {
                var sortingFunction = generateCardSortingFunction(true);
                cards.sort(sortingFunction);

                var straight = [];
                var ace = null;
                
                for (var i = 0; i < cards.length && straight.length < 5; i++) {
                    if (straight.length === 0) {
                        straight[0] = cards[i];
                    }
                    else if (isNextInStraight(cards, i, straight)) {
                        straight.push(cards[i]);
                    }
                    else if (!isDuplicate(cards, i, straight)) {
                        straight = [cards[i]];
                    }

                    if (cards[i].rank === 'A') {
                        ace = cards[i];
                    }
                }

                if (ace && is2345(straight)) {
                    straight.push(ace);
                }
                
                var result = straight.length === 5 ? straight : null;
                return result;
            }
            var isNextInStraight = function(cards, i, cardsMatched) {
                // ace high doesn't matter because aces will be logically accounted for
                var lastCardScore = getCardScore(cardsMatched[cardsMatched.length - 1].rank, true);

                return getCardScore(cards[i].rank, true) === lastCardScore - 1;
            }
            var isDuplicate = function(cards, i, cardsMatched) {
                // ace high doesn't matter because aces will be logically accounted for
                var lastCardScore = getCardScore(cardsMatched[cardsMatched.length - 1].rank, true);

                return getCardScore(cards[i].rank, true) === lastCardScore;
            }
            var is2345 = function(cards) {
                var numberOfMatches = 0;
                if (cards.length === 4) {
                    for (var i = 0; i < cards.length && numberOfMatches < 4; i++) {
                        var card = cards[i];
                        if (card.rank === '2' || card.rank === '3' || card.rank === '4' || card.rank === '5') {
                            numberOfMatches++;
                        }
                    }
                }

                return numberOfMatches === 4;
            }
            
            var getThreeofaKind = function(cards) {
                var cardsByRank = {};
                var threeOfaKind = null;
                
                for (var i = 0; i < cards.length; i++) {
                    var card = cards[i];
                    if (Object.keys(cardsByRank).includes(card.rank)) {
                        cardsByRank[card.rank].push(card);
                        if (cardsByRank[card.rank].length === 3) { // 4 of rank is automatically a better hand
                            threeOfaKind = cardsByRank[card.rank];
                        }
                    }
                    else {
                        cardsByRank[card.rank] = [card];
                    }
                }
                
                var maxRankingCard1 = null;
                var maxRankingCard2 = null;
                if (threeOfaKind) {
                    Object.keys(cardsByRank).forEach(rank => {
                        if (rank !== threeOfaKind[0].rank) {
                            if (maxRankingCard1 === null || getCardScore(rank) > getCardScore(maxRankingCard1.rank)) {
                                maxRankingCard1 = cardsByRank[rank][0];
                                if (cardsByRank[rank].length > 1) {
                                    maxRankingCard2 = cardsByRank[rank][1];
                                }
                            }
                            else if (maxRankingCard2 === null || getCardScore(rank) > getCardScore(maxRankingCard2.rank)) {
                                maxRankingCard2 = cardsByRank[rank][0];
                            }
                        }
                    });
                }
                
                var result = threeOfaKind ? threeOfaKind.concat([maxRankingCard1, maxRankingCard2]) : null;
                return result;
            }

            var getTwoPair = function(cards) {
                var isAceHigh = true;
                var sortingFunction = generateCardSortingFunction(isAceHigh);
                cards.sort(sortingFunction);

                var pair1 = null;
                var pair2 = null;
                var highCard = null;
                var cardsByRank = {};

                for (var i = 0; i < cards.length; i++) {
                    if (cardsByRank[cards[i].rank]) {
                        cardsByRank[cards[i].rank].push(cards[i]);
                    }
                    else {
                        cardsByRank[cards[i].rank] = [cards[i]];
                    }
                }
                
                Object.keys(cardsByRank).forEach(rank => {
                    var isMatch = false;          
                    if (cardsByRank[rank].length >= 2) {
                        if (!pair1 || getCardScore(pair1[0].rank) < getCardScore(rank)) {
                            isMatch = true;
                            pair2 = pair1;
                            pair1 = cardsByRank[rank].slice(0, 2);
                        }
                        else if (!pair2 || getCardScore(pair2[0].rank) < getCardScore(rank)) {
                            isMatch = true;
                            pair2 = cardsByRank[rank].slice(0, 2);
                        }
                    }
                    
                    var highCardScore = highCard ? getCardScore(highCard.rank) : 0;
                    if ((!isMatch || cardsByRank[rank].length > 2) && highCardScore < getCardScore(cardsByRank[rank][0].rank)) {
                        highCard = isMatch ? cardsByRank[rank][2] : cardsByRank[rank][0];
                    }
                });
                
                return (pair1 && pair2) ? pair1.concat(pair2).concat(highCard) : null;
            }

            var getPair = function(cards) {
                var isAceHigh = true;
                var sortingFunction = generateCardSortingFunction(isAceHigh);
                cards.sort(sortingFunction);

                var pair = null;
                var highCards = [];
                var cardsByRank = {};

                for (var i = 0; i < cards.length; i++) {
                    if (cardsByRank[cards[i].rank]) {
                        cardsByRank[cards[i].rank].push(cards[i]);
                    }
                    else {
                        cardsByRank[cards[i].rank] = [cards[i]];
                    }
                }
                
                Object.keys(cardsByRank).forEach(rank => {             
                    if (cardsByRank[rank].length >= 2) {
                        if (pair === null || getCardScore(pair[0].rank) < getCardScore(rank)) {
                            pair = cardsByRank[rank].slice(0, 2);
                        }
                    }
                });

                var maxRankingCard1 = null;
                var maxRankingCard2 = null;
                var maxRankingCard3 = null;
                if (pair) {
                    Object.keys(cardsByRank).forEach(rank => {
                        if (rank !== pair[0].rank || cardsByRank[rank].length > 2) {
                            var cardScore = getCardScore(rank, true);
                            
                            if (!maxRankingCard1 || cardScore > getCardScore(maxRankingCard1.rank, true)) {
                                maxRankingCard1 = cardsByRank[rank][0];
                            }
                            else if (!maxRankingCard2 || cardScore > getCardScore(maxRankingCard2.rank, true)) {
                                maxRankingCard2 = cardsByRank[rank][0];
                            }
                            else if (maxRankingCard3 === null || cardScore > getCardScore(maxRankingCard3.rank, true)) {
                                maxRankingCard3 = cardsByRank[rank][0];
                            }
                        }
                    });
                }
                
                return pair ? pair.concat([maxRankingCard1, maxRankingCard2, maxRankingCard3]) : null;
            }

            // smaller index equals higher ranked card
            var getHighCardAtIndex = function(cards, index) {
                var isAceHigh = true;
                var sortFunction = generateCardSortingFunction(isAceHigh);
                cards.sort(sortFunction);
                return cards[index];
            }

            var generateCardSortingFunction = function(isAceHigh, isAscending = false) {
                return function(a, b) {
                    var sortResult = 0;
                    var rankA = a ? a.rank || 0 : 0;
                    var rankB = b ? b.rank || 0 : 0;

                    if (isAscending) {
                        sortResult = getCardScore(rankA, isAceHigh) - getCardScore(rankB, isAceHigh);
                    }
                    else {
                        sortResult = getCardScore(rankB, isAceHigh) - getCardScore(rankA, isAceHigh);
                    }

                    return sortResult;
                };
            }

            var getCardScore = function(cardRank, isAceHigh = true) {
                var aceScore = isAceHigh ? 14 : 1;
                var cardRanks = {
                    'A': aceScore,
                    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,
                    '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
                };
                return cardRanks[cardRank];
            }

            // return { hand: [<card>], score: 1-10 (10 is highest ) }
            var getHandAndScore = function(cards) {
                var hand = null;
                var score = 10;

                var handCheckFunctions = [
                    getRoyalFlush,
                    getStraightFlush,
                    getFourofaKind,
                    getFullHouse,
                    getFlush,
                    getStraight,
                    getThreeofaKind,
                    getTwoPair,
                    getPair
                ];
                for (var i = 0; i < handCheckFunctions.length && !hand; i++) {
                    var tryMatchHand = handCheckFunctions[i];
                    hand = tryMatchHand(cards);
                    
                    if (!hand) {
                        score--;
                    }
                }

                if (!hand) {
                    hand = (cards.length > 5) ? cards.slice(0, 5) : cards;
                }
                return { hand, score };
            }
        </script>

        <!-- turn-taking logic -->
        <script>
            var cardsOnTable = []

            var setUserActions = function() {
                document.getElementById('button-call-check').onclick = function() {
                    var actionType = isCheck() ? 'check' : 'call';
                    onNextUserAction(actionType); 
                }

                document.getElementById('button-raise-bet').onclick = function() {
                    showBetAmountDialog();
                }

                document.getElementById('button-fold').onclick = function() {
                    onNextUserAction('fold');
                }
            }

            var setIsPlayedFalseExceptCurrentPlayer = function() {
                for (var i = 0; i < players.length; i++) {
                    players[i].isPlayed = (currentTurnIndex === i);
                }
            }

            /** actionType: 'check', 'call', 'bet', 'raise', 'fold'
            /* actionValue (any): bet/raise (number)
            */
            var onNextUserAction = function(actionType, actionValue) {
                var activePlayer = players[currentTurnIndex]; 
                var actionAmount = parseInt(actionValue) || 0;
                var isAllIn = false;
                var actionDisplayAmount;

                switch (actionType) {
                    case 'check': 
                        activePlayer.isPlayed = true;
                        break;
                    case 'call': 
                        activePlayer.isPlayed = true;
                        var amountToCall = currentBet - activePlayer.currentBet;
                        actionDisplayAmount = amountToCall;
                        if (amountToCall >= activePlayer.numberOfChips) {
                            isAllIn = true;
                            activePlayer.isOut = true;
                            actionDisplayAmount = activePlayer.numberOfChips;
                            activePlayer.numberOfChips = 0;
                        }
                        else {
                            activePlayer.numberOfChips -= amountToCall;
                        }
                        currentPotAmount += amountToCall;
                        activePlayer.currentBet = currentBet;
                        break;
                    case 'bet': 
                        setIsPlayedFalseExceptCurrentPlayer();
                        actionDisplayAmount = actionAmount;
                        if (actionAmount >= activePlayer.numberOfChips) {
                            isAllIn = true;
                            activePlayer.isOut = true;
                            actionDisplayAmount = activePlayer.numberOfChips;
                            activePlayer.numberOfChips = 0;
                        }
                        else {
                            activePlayer.numberOfChips -= actionAmount;
                        }
                        currentPotAmount += actionAmount;
                        activePlayer.currentBet = actionAmount;
                        currentBet = actionAmount;
                        break;
                    case 'raise': 
                        setIsPlayedFalseExceptCurrentPlayer();
                        actionDisplayAmount = actionAmount;
                        var totalBet = (currentBet - activePlayer.currentBet) + actionAmount;
                        if (totalBet >= activePlayer.numberOfChips) {
                            isAllIn = true;
                            activePlayer.isOut = true;
                            actionDisplayAmount = activePlayer.numberOfChips;
                            activePlayer.numberOfChips = 0;
                        }
                        else {
                            activePlayer.numberOfChips -= totalBet;
                        }
                        currentPotAmount += totalBet;
                        currentBet += actionAmount;
                        activePlayer.currentBet = currentBet;
                        break;
                    case 'fold':
                        activePlayer.isOut = true;
                        activePlayer.card1 = null;
                        activePlayer.card2 = null;
                        break;
                }

                var actionText = '';
                if (isAllIn) {
                    actionText = 'goes all in (' + actionDisplayAmount + ')';
                }
                else if (actionType === 'call' || actionType === 'raise' || actionType === 'bet') {
                    actionText = actionType + 's ' + actionDisplayAmount;
                }
                else {
                    actionText = actionType + 's';
                }
                setMessageText('Player "' + players[currentTurnIndex].name + '" ' + actionText + '.');

                if (currentPlayerIndex === currentTurnIndex) {
                    hideButtons();
                    stopUserOutlineAnimation();
                }

                endTurn();
            }

            var incrementTurnIndex = function(isBeforeDeal = false) {
                do {
                    currentTurnIndex = (currentTurnIndex + 1) % players.length;
                } while (
                    players[currentTurnIndex].numberOfChips <= 0 || !(isBeforeDeal || players[currentTurnIndex].card1)
                );
            }

            var getOnlyPlayerIn = function() {
                var playersIn = players.filter(player => {
                    return player.card1 !== null && player.card1 !== undefined;
                });
                return playersIn.length === 1 ? playersIn[0] : null;
            }

            var startNextTurn = function() {
                if (currentTurnIndex === currentPlayerIndex) {
                    showCallCheckButton();
                    showRaiseBetButton();
                    showFoldButton();
                    animateUserOutline();
                }
                // todo: else if human player then wait for their turn. 
                //      then, use events to update chip counts and actions for other players (add chips, bet/raise)
                else { // todo: get rid of this (remove beginAiTurn because server will handle AI and player sockets)
                    beginAiTurn();
                }
            }

            var getActivePlayersCount = function() {
                return players.filter(player => {
                    return !player.isOut;
                }).length;
            }
             
            var beginRound = function() {
                var activePlayersCount = getActivePlayersCount();
                if (activePlayersCount < 2) { // all players but one are all-in
                    roundNumber = NUMBER_OF_ROUNDS;
                    endTurn();
                }
                else {
                    currentTurnIndex = bigBlindIndex + 1;
                    incrementTurnIndex();

                    if (currentTurnIndex >= players.length) {
                        currentTurnIndex = 0;
                    }

                    currentBet = 0;
                    players.forEach(player => {
                        player.currentBet = 0;
                        player.isPlayed = false;
                    });

                    startNextTurn();
                }
            }
            
            var getHandDisplayName = function(score, cards) {
                var displayName = '';
                cards.sort(generateCardSortingFunction(true));
                var cardsDisplay = null;
                
                cards.forEach(card => {
                    var cardRank = card ? card.rank || '' : '';
                    if (!cardsDisplay) {
                        cardsDisplay = cardRank;
                    }
                    else {
                        cardsDisplay += ', ' + cardRank;
                    }
                });

                switch (score) {
                    case ROYAL_FLUSH_RANK: 
                        displayName = 'royal flush';
                        break;
                    case STRAIGHT_FLUSH_RANK:
                        displayName = 'straight flush: ' + cardsDisplay;
                        break;
                    case FOUR_OF_A_KIND_RANK:
                        displayName = '4 of a kind: ' + cardsDisplay;
                        break;
                    case FULL_HOUSE_RANK: 
                        displayName = 'full house: ' + cardsDisplay;
                        break;
                    case FLUSH_RANK:
                        displayName = 'flush (' + cards[0].suit + 's): ' + cardsDisplay;
                        break;
                    case STRAIGHT_RANK: 
                        displayName = 'straight: ' + cardsDisplay;
                        break;
                    case THREE_OF_A_KIND_RANK:
                        displayName = '3 of a kind: ' + cardsDisplay;
                        break;
                    case TWO_PAIR_RANK: 
                        displayName = '2 pair: ' + cardsDisplay;
                        break;
                    case PAIR_RANK: 
                        displayName = 'pair: ' + cardsDisplay;
                        break;
                    case HIGH_CARD_RANK:
                        displayName = 'high card: ' + cardsDisplay;
                        break;
                }

                return displayName;
            }

            var isAllPlayersPlayed = function() {
                var isAllPlayed = true;
                for (var i = 0; i < players.length && isAllPlayed; i++) {
                    isAllPlayed = isAllPlayed && (players[i].isPlayed || players[i].isOut);
                }

                return isAllPlayed;
            }

            var NUMBER_OF_ROUNDS = 4; // pre-flop, flop, turn, river
            var roundNumber = 1;
            var endTurn = function() {
                try {
                    var onlyPlayerIn = getOnlyPlayerIn();
                    var isRoundComplete = onlyPlayerIn || isAllPlayersPlayed(); 

                    if (isRoundComplete) {
                        if (onlyPlayerIn || cardsOnTable.length === 5) {
                            if (onlyPlayerIn) {
                                setMessageText(onlyPlayerIn.name + ' wins. All other players folded.');
                                onlyPlayerIn.numberOfChips += currentPotAmount;
                            }
                            else {
                                var winningPlayerRewards = determineWinningAmountsByPlayerIndex();
                                winningPlayerRewards.forEach(reward => {
                                    players[reward.playerIndex].numberOfChips += reward.winningAmount;
                                });
                            }

                            players.forEach(player => {
                                if (player.numberOfChips <= 0) {
                                    //setMessageText('Player ' + player.name + ' has run out of chips.');
                                    // todo: boot player, or let player add chips until their turn? 
                                    // also fix timing of this message
                                }
                            });
                            
                            // todo: maybe make animation of pot being rewarded or some shit
                            setTimeout(() => {
                                cardsOnTable = [];
                                roundNumber = 1;
                                
                                beginDeal(function() {
                                    startNextTurn();
                                });
                            }, 5000);
                        }
                        else {
                            roundNumber++;
                            drawCardFromDeck(); // burn card

                            if (roundNumber === 2) { // flop
                                var timeout = 0;
                                for (var i = 0; i < 3; i++) {
                                    setTimeout((index) => {
                                        cardsOnTable.push(drawCardFromDeck());
                                        if (index === 2) {
                                            beginRound();
                                        }
                                    }, timeout, i);
                                    timeout += 250;
                                }
                            }
                            else { // turn, river
                                cardsOnTable.push(drawCardFromDeck());
                                beginRound();
                            }
                        }
                    }
                    else {
                        incrementTurnIndex();
                        startNextTurn();
                    }
                } catch (error) {
                    // todo: refund chips and deal new hand?
                    setMessageText("error (end turn).");
                    alert("error: [ name:" + error.name + ", message:" + error.message + ", stack: " + error.stack + " ]");
                }
            }

            var ROYAL_FLUSH_RANK = 10;
            var STRAIGHT_FLUSH_RANK = 9;
            var FOUR_OF_A_KIND_RANK = 8;
            var FULL_HOUSE_RANK = 7;
            var FLUSH_RANK = 6;
            var STRAIGHT_RANK = 5;
            var THREE_OF_A_KIND_RANK = 4;
            var TWO_PAIR_RANK = 3;
            var PAIR_RANK = 2;
            var HIGH_CARD_RANK = 1;
            /** returns [{ playerIndex, winningAmount }] */
            var determineWinningAmountsByPlayerIndex = function() {
                var winners = [];
                var handsByPlayerName = {};
                var highestRank = 0;
                var isAceHighByPlayerName = {};

                players.forEach(player => {
                    if (player.card1 && player.card2) {
                        var allCards = cardsOnTable.concat(player.card1).concat(player.card2);
                        var hand = getHandAndScore(allCards);
                        
                        if (hand.score === highestRank) {
                            winners.push(player);
                            handsByPlayerName[player.name] = hand;
                        }
                        else if (hand.score > highestRank) {
                            highestRank = hand.score;
                            winners = [player];
                            handsByPlayerName = {};
                            handsByPlayerName[player.name] = hand;
                        }

                        if (hand.score >= highestRank && [STRAIGHT_FLUSH_RANK, STRAIGHT_FLUSH_RANK].includes(hand.score)) {
                            var athrough5 = ['A', '2', '3', '4', '5'];
                            for (var i = 0; i < hand.hand.length; i++) {
                                var isMatch = false;
                                for (var j = 0; j < athrough5 && !isMatch; j++) {
                                    if (hand.hand[i].rank === athrough5[j]) {
                                        isMatch = true;
                                        athrough5 = athrough5.slice(j, 1);
                                    }
                                }
                            }
                            isAceHighByPlayerName[player.name] = athrough5.length > 0;
                        }
                    }
                });

                var winningAmountsByPlayerIndex = null;
                if (winners.length > 1) {
                    // if royal then just split the pot because everybody's a winner
                    if ([STRAIGHT_FLUSH_RANK, STRAIGHT_RANK, FLUSH_RANK].includes(highestRank)) {
                        var highCardWinners = [];
                        var highCardScore = 0;
                        
                        winners.forEach(winner => {
                            var allCards = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var isAceHigh = isAceHighByPlayerName[winner.name];
                            var sortedCards = handsByPlayerName[winner.name].hand.sort(generateCardSortingFunction(isAceHigh));
                            
                            var highCard = sortedCards[0];
                            var cardScore = getCardScore(highCard.rank, isAceHigh);
                            if (cardScore > highCardScore) {
                                highCardScore = cardScore;
                                highCardWinners = [winner];
                            }
                            else if (cardScore === highCardScore) {
                                highCardWinners.push(winner);
                            }
                        });
                        winners = highCardWinners;
                    }
                    else if (highestRank === FOUR_OF_A_KIND_RANK) {
                        winners = getNofaKindWinners(winners, 4);
                    }
                    else if (highestRank === FULL_HOUSE_RANK) {
                        var highestThreeRank = 0;
                        var highestTwoRank = 0;
                        var highestThreeWinners;
                        var highestTwoWinners;

                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var cardsByRank = groupBy(hand, 'rank');
                            Object.keys(cardsByRank).forEach(rank => {
                                var cards = cardsByRank[rank];
                                var cardScore = getCardScore(rank);
                                if (cards.length === 3) {
                                    if (cardScore > highestThreeRank) {
                                        highestThreeRank = cardScore;
                                        highestThreeWinners = [winner];
                                    }
                                    else if (cardScore === highestThreeRank) {
                                        highestThreeWinners.push(winner);
                                    }
                                }
                                else if (cards.length === 2) {
                                     if (cardScore > highestTwoRank) {
                                         highestTwoRank = cardScore;
                                         highestTwoWinners = [winner];
                                     }
                                     else if (cardScore === highestTwoRank) {
                                         highestTwoWinners.push(winner);
                                     }
                                }
                            });
                        });

                        if (highestThreeWinners.length === 1 || highestTwoWinners.length > 1) {
                            winners = highestThreeWinners;
                        }
                        else {
                            winners = highestTwoWinners;
                        }
                    }
                    else if (highestRank === THREE_OF_A_KIND_RANK) {
                        setMessageText("noble")
                        winners = getNofaKindWinners(winners, 3);
                    }
                    else if (highestRank === TWO_PAIR_RANK) {
                        var highestPair1Score = 0;
                        var highestPairWinners = [];
                        var highestPair2Score = 0;
                        var highCardScore = 0;

                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var cardsByRank = groupBy(hand, 'rank');
                            var highestPairScore = 0;
                            var secondHighestPairScore = 0;
                            var highestCardScore = 0;

                            Object.keys(cardsByRank).forEach(rank => { 
                                var cardScore = getCardScore(rank);
                                if (cardsByRank[rank].length === 2) {
                                    if (cardScore > highestPairScore) {
                                        highestPairScore = cardScore;
                                    }
                                    else if (cardScore > secondHighestPairScore) {
                                        secondHighestPairScore = cardScore;
                                    }
                                    else if (cardScore > highestCardScore) {
                                        highestCardScore = cardScore;
                                    }
                                }
                                else if (cardScore > highestCardScore) { // must be single card cuz 3+ would automatically be a better hand
                                    highestCardScore = cardScore;
                                }
                            });

                            if (highestPairScore > highestPair1Score) {
                                highestPair1Score = highestPairScore;
                                highestPair2Score = secondHighestPairScore;
                                highCardScore = highestCardScore;
                                highestPairWinners = [winner];
                            }
                            else if (highestPairScore === highestPair1Score) {
                                if (secondHighestPairScore > highestPair2Score) {
                                    highestPair1Score = highestPairScore;
                                    highestPair2Score = secondHighestPairScore;
                                    highCardScore = highestCardScore;
                                    highestPairWinners = [winner];
                                }
                                else if (secondHighestPairScore === highestPair2Score) {
                                    if (highestCardScore > highCardScore) {
                                        highestPair1Score = highestPairScore;
                                        highestPair2Score = secondHighestPairScore;
                                        highCardScore = highestCardScore;
                                        highestPairWinners = [winner];
                                    }
                                    else if (highestCardScore === highCardScore) {
                                        highestPairWinners.push(winner);
                                    }
                                }
                            }
                        });

                        winners = highestPairWinners;
                    }
                    else if (highestRank === PAIR_RANK) {
                        var highPairScore = 0;
                        var highPairWinners = [];
                        var highCardScores = []; // highest cards in desc order

                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var cardsByRank = groupBy(hand, 'rank');
                            var highestPairScore = 0;
                            var highestCardScores = [];

                            Object.keys(cardsByRank).forEach(rank => { 
                                var cardScore = getCardScore(rank);
                                if (cardsByRank[rank].length === 2 && cardScore > highestPairScore) {
                                    highestPairScore = cardScore;
                                }
                                else { // must be single card cuz 3+ would automatically be a better hand
                                    if (highestCardScores.length < 3) {
                                        highestCardScores.push(cardScore);
                                        if (highestCardScores.length === 3) {
                                            highestCardScores.sort((a, b) => { return b - a; });
                                        }
                                    }
                                    else {
                                        var swappedScore = null;
                                        for (var i = 0; i < highestCardScores.length; i++) {
                                            if (swappedScore) {
                                                var tempScore = highestCardScores[i];
                                                highestCardScores[i] = swappedScore;
                                                swappedScore = tempScore;
                                            }
                                            else if (cardScore > highestCardScores[i]) {
                                                swappedScore = highestCardScores[i]
                                                highestCardScores[i] = cardScore;
                                            }
                                        }
                                    }
                                }
                            });

                            if (highestPairScore > highPairScore) {
                                highPairScore = highestPairScore;
                                highPairWinners = [winner];
                                highCardScores = highestCardScores;
                            }
                            else if (highestPairScore === highPairScore) {
                                var isTied = true;
                                for (var i = 0; i < highCardScores.length && isTied; i++) {
                                    if (highestCardScores[i] > highCardScores[i]) {
                                        highPairWinners = [winner];
                                        highCardScores = highestCardScores;
                                        isTied = false;
                                    }
                                    else {
                                        isTied = highestCardScores[i] === highCardScores[i];
                                    }
                                }

                                if (isTied) {
                                    highPairWinners.push(winner);
                                }
                            }
                        });

                        winners = highPairWinners;
                    }
                    else if (highestRank === HIGH_CARD_RANK) { // high card
                        var highCardScores = [];
                        var highCardWinners = [];

                        var finalWinners = [];
                        winners.forEach(winner => {
                            var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                            var sortedHand = hand.sort(generateCardSortingFunction(true));
                            var cardScores = sortedHand.map(card => {
                                return getCardScore(card.rank, true);
                            });

                            if (highCardScores.length === 0) {
                                highCardScores = cardScores;
                                highCardWinners = [winner];
                            }
                            else {
                                var isReplaced = false;
                                var isEqual = true;
                                for (var i = 0; i < cardScores.length && !isReplaced; i++) {
                                    isReplaced = cardScores[i] > highCardScores[i];
                                    isEqual = cardScores[i] === highCardScores[i];
                                }

                                if (isReplaced) {
                                    highCardScores = cardScores;
                                    highCardWinners = [winner];
                                }
                                else if (isEqual) {
                                    highCardWinners.push(winner);
                                }
                            }

                            finalWinners = highCardWinners;
                        });
                        winners = finalWinners;
                    }
                
                    winningAmountsByPlayerIndex = getWinningAmountsByPlayerIndex(winners);
                }
                else { // single winner
                    var winningIndex;
                    var isIndexFound = false;
                    for (var i = 0; i < players.length && !isIndexFound; i++) {
                        if (players[i].name === winners[0].name) {
                            winningIndex = i;
                            isIndexFound = true;
                        }
                    }

                    winningAmountsByPlayerIndex = [{
                        playerIndex: winningIndex,
                        winningAmount: currentPotAmount
                    }];
                }

                var playerWord = 'Player';
                var winWord = 'wins';
                if (winningAmountsByPlayerIndex.length > 1) {
                    playerWord = 'Players';
                    winWord = 'win';
                }
                var playerName = null;
                winningAmountsByPlayerIndex.forEach(amountByIndex => {
                    var name = players[amountByIndex.playerIndex].name;
                    if (!playerName) {
                        playerName = name;
                    }
                    else {
                        playerName += ', ' + name;
                    }
                });
                
                var hand = handsByPlayerName[players[winningAmountsByPlayerIndex[0].playerIndex].name];
                var handName = getHandDisplayName(highestRank, hand.hand);
                setMessageText(playerWord + ' ' + playerName + ' ' + winWord + ' with ' + handName);

                return winningAmountsByPlayerIndex;
            }

            var getNofaKindWinners = function(players, n) {
                var highestNScore = 0;
                var highestNWinners = [];

                var winners = [];
                players.forEach(winner => {
                    var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                    var cardsByRank = groupBy(hand, 'rank');
                    var nOfakindCard;
                    var ranks = Object.keys(cardsByRank);
                    for (var i = 0; i < ranks.length && !nOfakindCard; i++) {
                        if (cardsByRank[ranks[i]].length === n) {
                            nOfakindCard = cardsByRank[ranks[i]][0];
                        }
                    }

                    var cardScore = getCardScore(nOfakindCard.rank, true);
                    if (cardScore > highestNScore) {
                        highestNScore = cardScore;
                        highestNWinners = [winner];
                    }
                    else if (cardScore === highestNScore) {
                        highestNWinners.push(winner);
                    }
                });
                
                if (highestNWinners.length > 1) {
                    var highestCardWinners = []
                    var highestCardScores = null;
                    
                    highestNWinners.forEach(winner => {
                        var hand = cardsOnTable.concat(winner.card1).concat(winner.card2);
                        var cardsByRank = groupBy(hand, 'rank'); 
                        var ranks = Object.keys(cardsByRank);
                        var highCardScores = [];
                        for (var i = 0; i < ranks.length; i++) {
                            if (cardsByRank[ranks[i]].length < n) {
                                var scores = cardsByRank[ranks[i]].map(card => { return getCardScore(card.rank) });
                                highCardScores = highCardScores.concat(scores);
                            }
                        }
                        highCardScores.sort(function(a, b) { return b - a });

                        if (!highestCardScores) {
                            highestCardScores = highCardScores;
                            highestCardWinners = [winner];
                        }
                        else {
                            var isReplaced = false;
                            var isEqual = true;
                            for (var i = 0; i < highCardScores.length && !isReplaced; i++) {
                                isReplaced = highCardScores[i] > highestCardScores[i];
                                isEqual = isEqual && highCardScores[i] === highestCardScores[i];
                            }

                            if (isReplaced) {
                                highestCardScores = highCardScores;
                                highestCardWinners = [winner];
                            }
                            else if (isEqual) {
                                highestCardWinners.push(winner);
                            }
                        }
                    });

                    winners = highestCardWinners;
                }
                else {
                    winners = highestNWinners;
                }

                return winners;
            }

            // return [{ playerIndex, winningAmount }]
            var getWinningAmountsByPlayerIndex = function(winners) {
                var winningAmountsByPlayerIndex = [];
                var winningNames = winners.map(function(winner) { return winner.name });
                for (var i = 0; i < players.length; i++) {
                    if (winningNames.includes(players[i].name)) {
                        winningAmountsByPlayerIndex.push({
                            playerIndex: i,
                            winningAmount: parseInt(currentPotAmount / winners.length)
                        });
                    }
                }

                return winningAmountsByPlayerIndex;
            }

            var groupBy = function(items, propertyName) {
                var groups = {};
                items.forEach(item => {
                    if (groups[item[propertyName]]) {
                        groups[item[propertyName]].push(item);
                    }
                    else {
                        groups[item[propertyName]] = [item];
                    }
                });

                return groups;
            }
        </script>

        <!-- Base logic function (draw, update) -->
        <script>
            var draw = function(canvas) {
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                var tableX = parseInt(canvas.width * 0.15);
                var tableY = parseInt(canvas.height * 0.15);
                var tableWidth = parseInt(canvas.width * 0.65);
                var tableHeight = parseInt(canvas.height * 0.25);

                drawTable(ctx, tableX, tableY, tableWidth, tableHeight);
                drawPlayers(ctx, getPlayers(), tableX, tableY, tableWidth, tableHeight);

                if (currentPlayerIndex === 0 || currentPlayerIndex) {
                    drawUserHand(ctx, canvas);
                }

                if (areBlindsSet()) {
                    drawBlinds(ctx, tableX, tableY, tableWidth, tableHeight);
                }
                drawPlayerHands(ctx, tableX, tableY, tableWidth, tableHeight);

                drawCardsOnTable(ctx, tableX, tableY, tableWidth, tableHeight);
                var potAmount = currentPotAmount || 0;
                drawPot(ctx, potAmount, tableX, tableY, tableWidth, tableHeight);
            }
        </script>

        <script>
            var players = [];
            var currentPlayerIndex;

            window.onload = function() {
                setUserActions();

                /// GAME READY/INIT
                document.addEventListener("message", function(event) {
                    var messageData = JSON.parse(event.data);
                    players = messageData.players;
                    currentPlayerIndex = messageData.currentPlayerIndex || 0;

                    bigBlindAmount = 10;
                    littleBlindAmount = 5;

                    beginDeal(function() {
                        startNextTurn();
                    });
                });

                var canvas = document.getElementById('tableCanvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                var canvasRect = canvas.getBoundingClientRect();

                loadSpritesConfig();
                loadButtons(canvasRect.left, canvasRect.top, canvas.width, canvas.height);
                loadDialogs(canvasRect.left, canvasRect.top, canvas.width, canvas.height);

                setInterval(function() {
                    draw(canvas);
                }, 1000 / 24);
            }
        </script>

        
    </body>
</html>